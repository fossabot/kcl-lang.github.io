"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[11477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"2022-kcl-0.4.6-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.6-release-blog","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2023-04-14-kcl-0.4.6-release/index.md","source":"@site/blog/2023-04-14-kcl-0.4.6-release/index.md","title":"KCL v0.4.6 Release Blog","description":"Introduction","date":"2023-04-14T00:00:00.000Z","formattedDate":"April 14, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"KusionStack","permalink":"/blog/tags/kusion-stack"},{"label":"Kusion","permalink":"/blog/tags/kusion"}],"readingTime":8.045,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.6-release-blog","title":"KCL v0.4.6 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL","KusionStack","Kusion"]},"nextItem":{"title":"KCL Introduction on OS2ATC 2022 Meeting","permalink":"/blog/2023-03-26-kcl-os2atc-meeting"}},"content":"\x3c!-- KCL v0.4.6 is Coming - New IDE Extension, Helm/Kustomize/KPT Integrations--\x3e\\n\\n## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.4.6 is now available! This release has brought three key updates to everyone: **Language**, **Tools**, and **Integrations**.\\n\\n+ *Use KCL IDE extensions to improve KCL code writing experience and efficiency*\\n+ *Helm/Kustomize/KPT cloud-native community tool integrations*\\n+ *Improve the KCL multilingual SDK for easy application integration*\\n\\nYou can visit the [KCL release page](https://github.com/KusionStack/KCLVM/releases/tag/v0.4.6) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/KusionStack/KCLVM) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.4.6 and recent developments in the KCL community to readers.\\n\\n## Language\\n\\n### Builtin Functions\\n\\nAdded KCL string `removeprefix` and `removesuffix` member functions to remove prefix and suffix substrings from strings\\n\\n```python\\ndata1 = \\"prefix-string\\".removeprefix(\\"prefix-\\") # \\"string\\" \\ndata2 = \\"string-suffix\\".removesuffix(\\"-suffix\\") # \\"string\\"\\n```\\n\\nSee [here](https://kcl-lang.io/docs/reference/model/builtin#string-builtin-member-functions) for more.\\n\\n### Compiler Information\\n\\nIn previous versions of KCL, running the KCL command-line tool once only displayed one error message and warning. In KCL v0.4.6, it supported the ability to display multiple errors and warnings in one compilation and improved error information to improve the efficiency of KCL code error troubleshooting, such as for the following KCL code (main.k).\\n\\n```python\\nmetadata = {\\n    labels = {key = \\"kcl\\n}\\n```\\n\\nExecute the following KCL command, then you can see the syntax errors including the unterminated string and the brace mismatch errors.\\n\\n```shell\\n$ kcl main.k\\nerror[E1001]: InvalidSyntax\\n --\x3e main.k:2:21\\n  |\\n2 |     labels = {key = \\"kcl\\n  |                     ^ unterminated string\\n  |\\n\\nerror[E1001]: InvalidSyntax\\n --\x3e main.k:2:24\\n  |\\n2 |     labels = {key = \\"kcl\\n  |                        ^ expected \\"}\\"\\n  |\\n```\\n\\n### Top-level schema assign statement union operator\\n\\nIn previous versions of KCL, when writing the following KCL code, the two schema configurations with the same name were merged and output. In KCL v0.4.6, it was required to explicitly use the attribute merge operator instead of the attribute overlay operator.\\n\\n+ Before\\n\\n```python\\nschema Config:\\n    id?: int\\n    value?: str\\n\\nconfig = Config {\\n    id = 1\\n}\\nconfig = Config {\\n    value = \\"value\\"\\n}\\n```\\n\\n+ After\\n\\n```python\\nschema Config:\\n    id?: int\\n    value?: str\\n\\n# Use the union operator `:` instead of the override operator\\nconfig: Config {\\n    id = 1\\n}\\n# Use the union operator `:` instead of the override operator\\nconfig: Config {\\n    value = \\"value\\"\\n}\\n```\\n\\n### Bugfix\\n\\n#### Inline conditional configuration block syntax error\\n\\nBefore KCL v0.4.6, an unexpected syntax error will appear when writing the following KCL code. In the new version, we fixed similar issues.\\n\\n```python\\nenv = \\"prod\\"\\nconfig = {if env == \\"prod\\": labels = {\\"kubernetes.io/env\\" = env}}\\n```\\n\\n#### Schema required attribute check\\n\\nIn previous versions of KCL, for the following KCL code, there was an error where the `versions` attribute was not assigned as expected. In KCL v0.4.6, we fixed similar issues.\\n\\n```python\\nschema App:\\n    data?: [int]\\n    version: Version\\n\\nschema Version:\\n    versions: [str]\\n\\napp = App {\\n    version = Version {}\\n}\\n```\\n\\n## Tools\\n\\n### KCL VS Code Extension\\n\\nIn this version, we have released a new KCL VS Code extension and a language service server rewritten using the Rust language, which has improved performance by about 20 times compared to previous KCL IDE versions. We also support real-time display of KCL errors and warnings in the IDE, as well as new features such as KCL code completion.\\n\\n+ **Real-time display of KCL errors and warnings**\\n\\n![Diagnostics](/img/docs/tools/Ide/vs-code/Diagnostics.gif)\\n\\n+ **Go to Definition**\\n\\n![Goto Definition](/img/docs/tools/Ide/vs-code/GotoDef.gif)\\n\\n+ **Completion**\\n\\n![Completion](/img/docs/tools/Ide/vs-code/Completion.gif)\\n\\n+ **Hover**\\n\\n![Hover](/img/docs/tools/Ide/vs-code/Hover.gif)\\n\\nSee [here](https://kcl-lang.io/docs/tools/Ide/vs-code) for more.\\n\\n### Kusion VS Code Extension\\n\\nOn the basis of the KCL VS Code extension, we also provide a Kusion VS Code extension that is more closely integrated with cloud-native scenarios, supporting one-click application configuration preview and deploying. See [here](https://github.com/KusionStack/vscode-kusion) for more.\\n\\n### Package Management Tools\\n\\nIn the new version of KCL v0.4.6, we have provided a new KCL package management tool with the alpha version, which allows users to access the KCL modules in the community with a few commands. For example, the KCL Kubernetes model can be imported through the following command.\\n\\n```shell\\nkpm init kubernetes_demo && kpm add -git https://github.com/awesome-kusion/konfig.git -tag v0.0.1\\n```\\n\\nWrite a KCL code to import the Kubernetes models (main.k).\\n\\n```python\\nimport konfig.base.pkg.kusion_kubernetes.api.apps.v1 as apps\\n\\ndemo = apps.Deployment {\\n    metadata.name = \\"nginx-deployment\\"\\n    spec = {\\n        replicas = 3\\n        selector.matchLabels.app = \\"nginx\\"\\n        template.metadata.labels = selector.matchLabels\\n        template.spec.containers = [\\n            {\\n                name = selector.matchLabels.app\\n                image = \\"nginx:1.14.2\\"\\n                ports = [\\n                    {containerPort = 80}\\n                ]\\n            }\\n        ]\\n    }\\n}\\n```\\n\\nExecute the following command to run the KCL code to obtain an nginx deployment YAML output.\\n\\n```shell\\n$ kcl main.k -S demo\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\nspec:\\n  replicas: 3\\n  selector:\\n    matchLabels:\\n      app: nginx\\n  template:\\n    metadata:\\n      labels:\\n        app: nginx\\n    spec:\\n      containers:\\n        - image: \\"nginx:1.14.2\\"\\n          name: nginx\\n          ports:\\n            - containerPort: 80\\n```\\n\\n+ See [here](https://kcl-lang.io/docs/user_docs/guides/package-management/overview) for more information about the **kpm** tool.\\n+ See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-konfig/overview) for more information about the **konfig** model.\\n\\n## Integrations\\n\\n### Kubernetes Tool Integrations\\n\\nIn KCL v0.4.6, we provide KCL plugin support for configuration management tools such as Helm, Kustomize, and KPT in the Kubernetes community using a unified programming interface. Writing a few lines of KCL code can non-intrusively complete the mutation and validation of existing Kustomize YAML and Helm Charts.\\n\\nFor example, writing a small amount of KCL code to modify resource labels/annotations, injecting sidecar container configuration, and using KCL schema to verify resources.\\n\\nBelow is a detailed explanation of the integration of KCL using the Kustomize tool. There is no need to install any KCL-related binaries to use the Kustomize KCL plugin, just install the Kustomize tool locally.\\n\\nFirstly, execute the following command to obtain a Kustomize YAML configuration example:\\n\\n```shell\\ngit clone https://github.com/KusionStack/kustomize-kcl.git &&cd ./kustomize-kcl/examples/set-annotation/\\n```\\n\\nThen execute the following command using KCL code to add only one `managed-by=kustomize-kcl` annotation for all `Deployment` resources\\n\\n```shell\\nsudo kustomize fn run ./local-resource/ --as-current-user --dry-run\\n```\\n\\nThe output YAML is:\\n\\n```yaml\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: test\\n  annotations:\\n    config.kubernetes.io/path: example-use.yaml\\n    internal.config.kubernetes.io/path: example-use.yaml\\nspec:\\n  selector:\\n    app: MyApp\\n  ports:\\n  - protocol: TCP\\n    port: 80\\n    targetPort: 9376\\n---\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\n  labels:\\n    app: nginx\\n  annotations:\\n    config.kubernetes.io/path: example-use.yaml\\n    internal.config.kubernetes.io/path: example-use.yaml\\n    # This annotation is added through the kcl code.\\n    managed-by: kustomize-kcl\\nspec:\\n  replicas: 3\\n  selector:\\n    matchLabels:\\n      app: nginx\\n  template:\\n    metadata:\\n      labels:\\n        app: nginx\\n    spec:\\n      containers:\\n      - name: nginx\\n        image: nginx:1.14.2\\n        ports:\\n        - containerPort: 80\\n```\\n\\nIn the YAML configuration mentioned above, we only wrote one line of KCL code to add a `managed-by=kustomize-kcl` annotation to all deployment resources.\\n\\n```python\\n[resource | {if resource.kind == \\"Deployment\\": metadata.annotations: {\\"managed-by\\" = \\"kcl\\"}} for resource in option(\\"resource_list\\").item]\\n```\\n\\nIn addition, we have provided commonly used container and service configuration mutation and validation KCL models for Kustomize/Helm/KPT tools and will continue to improve them.\\n\\n+ See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/kustomize_kcl_plugin) for more information about the Kustomize KCL plugin.\\n+ See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/helm_kcl_plugin) for more information about the Helm KCL Plugin.\\n+ See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/kpt_kcl_sdk) for more information about the KPT KCL Plugin.\\n\\n### Multilingual SDK\\n\\nIn this new version, we have released a new kclvm-go SDK that integrates KCL into your Go application and provides rich APIs for interacting with KCL. You can click [here](https://kcl-lang.io/docs/next/reference/xlang-api/go-api) for detailed API documents. In addition, we have also updated the following features and bug fixes:\\n\\n+ Thank @jakezhu9 for fixing unexpected KCL formatting API unit testing errors in CI Pipeline for kclvm-go.\\n+ Thank @Ekko for contributing to the bidirectional conversion support of Go struct and KCL schema. Please refer to:\\n  + [Go struct -> KCL schema](https://github.com/KusionStack/kclvm-go/blob/main/pkg/tools/gen/genkcl.go#L23)\\n  + [KCL schema -> Go struct](https://github.com/KusionStack/kclvm-go/blob/main/pkg/tools/gen/gengo.go#L23)\\n+ Support for conversion from KCL schema to protobuf message, see [here](https://github.com/KusionStack/kclvm-go/blob/main/pkg/tools/gen/genpb.go#L25) for more.\\n+ Support APIs for obtaining schema types and instances from the KCL code, see [here](https://kcl-lang.io/docs/reference/xlang-api/go-api#func-getschematype) for more.\\n\\n## Other updates and bug fixes\\n\\n+ The KCL Python plugin function is not enabled by default. If you need to enable it, please refer to the [plugin document](https://kcl-lang.io/docs/reference/plugin/overview).\\n+ KCL playground supports code-sharing capabilities, which can be accessed by visiting the [KCL website](https://kcl-lang.io/) and clicking on the playground button to experience.\\n+ See [here](https://github.com/KusionStack/KCLVM/milestone/3?closed=1) for more updates and bug fixes.\\n\\n## Documents\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.3, v0.4.4, v0.4.5, and v0.4.6 versions are supported.\\n\\n## Next\\n\\nIt is expected that in the middle of 2023, we will release **KCL v0.5.0**. The expected key evolution includes:\\n\\n+ More IDE extensions, package management tools, Helm/Kustomize/KPT scenario integration, feature support, and user experience improvement.\\n+ Provide more out-of-box KCL model support for cloud-native scenarios, mainly including containers, services, computing, storage, and networks.\\n+ Support KCL Schema to directly generate Kubernetes CRD.\\n+ Support `kubectl` and `helmfile` KCL plugins, directly generating, mutating, and validating Kubernetes resources through the KCL code.\\n+ Support for mutating and validating YAML by running KCL code through the admission controller at the Kubernetes runtime.\\n+ More support for non-Kubernetes scenarios, such as data cleaning of AI models through the KCL schema and database schema integration support.\\n\\nFor more details, please refer to [KCL v0.5.0 Milestone](https://github.com/KusionStack/KCLVM/milestone/5)\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/KusionStack/KCLVM)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/KusionStack/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2023-03-26-kcl-os2atc-meeting","metadata":{"permalink":"/blog/2023-03-26-kcl-os2atc-meeting","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2023-03-26-kcl-os2atc-meeting/index.md","source":"@site/blog/2023-03-26-kcl-os2atc-meeting/index.md","title":"KCL Introduction on OS2ATC 2022 Meeting","description":"Download PDF","date":"2023-03-26T00:00:00.000Z","formattedDate":"March 26, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"},{"label":"Policy","permalink":"/blog/tags/policy"}],"readingTime":0.01,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-03-26-kcl-os2atc-meeting","title":"KCL Introduction on OS2ATC 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration","Policy"]},"prevItem":{"title":"KCL v0.4.6 Release Blog","permalink":"/blog/2022-kcl-0.4.6-release-blog"},"nextItem":{"title":"KCL v0.4.6-alpha.1 Release Blog","permalink":"/blog/2022-kcl-0.4.6-alpha.1-release-blog"}},"content":"[Download PDF](https://kcl-lang.github.io/talks/kcl-os2atc2022.pdf)"},{"id":"2022-kcl-0.4.6-alpha.1-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.6-alpha.1-release-blog","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2023-03-20-kcl-0.4.6-alpha.1-release/index.md","source":"@site/blog/2023-03-20-kcl-0.4.6-alpha.1-release/index.md","title":"KCL v0.4.6-alpha.1 Release Blog","description":"Introduction","date":"2023-03-20T00:00:00.000Z","formattedDate":"March 20, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"KusionStack","permalink":"/blog/tags/kusion-stack"},{"label":"Kusion","permalink":"/blog/tags/kusion"}],"readingTime":1.17,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.6-alpha.1-release-blog","title":"KCL v0.4.6-alpha.1 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL","KusionStack","Kusion"]},"prevItem":{"title":"KCL Introduction on OS2ATC 2022 Meeting","permalink":"/blog/2023-03-26-kcl-os2atc-meeting"},"nextItem":{"title":"The new playground of the KCL programming language is coming!","permalink":"/blog/2023-kcl-playground-0.4.5-release"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.4.6-alpha.1 is now available!\\n\\nYou can visit the [KCL release page](https://github.com/KusionStack/KCLVM/releases/tag/v0.4.6-alpha.1) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/KusionStack/KCLVM) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\n## Release Content\\n\\n+ Lexical error recovery including numbers, literal values, parentheses, etc\\n+ KCL IDE plug-in supports error and warning display, go-to-definition, and other capabilities.\\n+ Some compiler error reporting improvements\\n+ KCL Playground supports code sharing capabilities\\n+ [KPT Tool KCL SDK](https://github.com/KusionStack/KCLVM/issues/434)\\n+ [Helm KCL Plugin](https://github.com/KusionStack/KCLVM/issues/426)\\n\\n## Next\u200b\\n\\n+ KPM package management tool release\\n+ More KCL compiler syntax error recovery supports the release of new IDE plug-ins, with an expected performance improvement of 20 times\\n+ KCL integration of Kubernetes tools such as Helm and KPT release\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/KusionStack/KCLVM)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/KusionStack/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2023-kcl-playground-0.4.5-release","metadata":{"permalink":"/blog/2023-kcl-playground-0.4.5-release","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2023-03-17-kcl-playground-0.4.5-release/index.md","source":"@site/blog/2023-03-17-kcl-playground-0.4.5-release/index.md","title":"The new playground of the KCL programming language is coming!","description":"Introduction","date":"2023-03-17T00:00:00.000Z","formattedDate":"March 17, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"KusionStack","permalink":"/blog/tags/kusion-stack"},{"label":"Kusion","permalink":"/blog/tags/kusion"},{"label":"Playground","permalink":"/blog/tags/playground"}],"readingTime":0.995,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-kcl-playground-0.4.5-release","title":"The new playground of the KCL programming language is coming!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL","KusionStack","Kusion","Playground"]},"prevItem":{"title":"KCL v0.4.6-alpha.1 Release Blog","permalink":"/blog/2022-kcl-0.4.6-alpha.1-release-blog"},"nextItem":{"title":"KCL v0.4.5 Release Blog","permalink":"/blog/2022-kcl-0.4.5-release-blog"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that the new playground of KCL v0.4.5 is now available!\\n\\n[KCL](https://github.com/KusionStack/KCLVM) is an open-source, constraint-based record and functional language. KCL improves the complexity of writing numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nYou can visit the [KCL website](https://kcl-lang.io/) and click the playground link and play. In this new version, we support the ability to automatically compile and run KCL code, format it, and share code. Welcome to writing and sharing KCL codes.\\n\\n![](/img/blog/2023-03-17-kcl-playground-0.4.5-release/kcl-website-playground.png)\\n\\n![](/img/blog/2023-03-17-kcl-playground-0.4.5-release/kcl-playground.png)\\n\\n## Next\u200b\\n\\nIt is expected that in the middle of April 2023, we will release a new KCL Playground including KCL version selection, reference to Github code, and other capabilities.\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/KusionStack/KCLVM)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/KusionStack/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-0.4.5-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.5-release-blog","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2023-02-27-kcl-0.4.5-release-blog/index.md","source":"@site/blog/2023-02-27-kcl-0.4.5-release-blog/index.md","title":"KCL v0.4.5 Release Blog","description":"Introduction","date":"2023-02-27T00:00:00.000Z","formattedDate":"February 27, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"KusionStack","permalink":"/blog/tags/kusion-stack"},{"label":"Kusion","permalink":"/blog/tags/kusion"}],"readingTime":11.215,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.5-release-blog","title":"KCL v0.4.5 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL","KusionStack","Kusion"]},"prevItem":{"title":"The new playground of the KCL programming language is coming!","permalink":"/blog/2023-kcl-playground-0.4.5-release"},"nextItem":{"title":"KCL Introduction on OSDT 2022 Meeting","permalink":"/blog/2022-kcl-osdt-meeting"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.4.5 is now available! This release is mainly aimed at improving the convenience and stability of KCL language writing, improving error information, and supporting more platforms including Windows version and more download methods. In KCL v0.4.5, users can eliminate more configuration templates by writing fewer KCL codes. In the new version, preliminary KCL Playground support is provided, which can be used to write and run KCL code online without installation. In addition, this release also includes many compiler error information optimization and bug fixes.\\n\\nYou can visit the [KCL release page](https://github.com/KusionStack/KCLVM/releases/tag/v0.4.5) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/KusionStack/KCLVM) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.4.5 and recent developments in the KCL community to readers.\\n\\n## Features\\n\\n### Language Writing Convenience Improvement\\n\\n#### Lazy Validation of Non-null Attributes in the KCL Schema\\n\\nIn previous KCL versions, we have supported the lazy evaluation and validation capabilities of schema attribute cross-reference (including inheritance) and check expressions. In this version, we have supported more schema lazy evaluation capabilities such as the schema attribute non-null lazy validation. For example, for the following KCL codes:\\n\\n```python\\nschema Spec:\\n    id: int\\n    value: str\\n\\nschema Config:\\n    name?: str\\n    spec: Spec = Spec {  \\n        id = 1\\n    } # Before KCL v0.4.5, this statement will report an attribute non-null error. After v0.4.5, the schema non-null attribute lazy validation is supported\\n\\nconfig = Config {\\n    spec.value = \\"value\\"\\n}\\n```\\n\\nBefore KCL v0.4.5, directly executing the above code will throw an error that the `value` attribute of `spec` cannot be `None` at the `spec: Spec=Spec {` statement block of the `schema Config`, because only the `id` attribute of `spec` is assigned a value of `1`, and no value is assigned to the `value` attribute of `spec`.\\n\\nAfter KCL v0.4.5, we will avoid throwing this error after supporting the lazy non-null validation capability of the schema attribute. That is, when the `spec.value=\\"value\\"` and `spec.id=1` of the `config` attributes are merged, all the attributes of `config` will be checked recursively for non-null. At this time, all the values of the `spec` attribute are fully assigned (the value of the `id` attribute of `spec` is `1`, and the `value` attribute is `\\"value\\"`), the error that the required schema attribute is null will not be thrown.\\n\\nTherefore, after KCL v0.4.5 and executing the above KCL code, we will get the complete YAML output as follows:\\n\\n```yaml\\nconfig:\\n  spec:\\n    id: 1\\n    value: value\\n```\\n\\n#### Mutual Reference of Configuration Block Attributes\\n\\nIn versions before v0.4.5, KCL has not yet supported the mutual reference of attributes within the configuration block, resulting in the need to define additional configuration variables or templates for reference in some scenarios, resulting in more configuration templates and duplicate codes, such as the KCL code shown below:\\n\\n```python\\nname = \\"app-name\\"\\ndata = {\\n    name = name\\n    metadata.name = name  # `metadata.name` cannot directly reference the `name` attribute inside the `data` configuration.\\n}\\n```\\n\\nThe `metadata.name` attribute of the `data` configuration block cannot directly reference the `name` attribute inside the `data`. We need to define an additional global variable `name` for reference.\\n\\nAfter KCL v0.4.5, we support the feature of mutual reference of configuration block attributes, which can be used to eliminate more configuration templates, such as the KCL code shown below:\\n\\n```python\\ndata = {\\n    name = \\"app-name\\"\\n    metadata.name = name  # Directly reference the name attribute of the `data` configuration\\n}\\n```\\n\\nThe `metadata.name` attribute of the `data` configuration block can directly reference the `name` attribute inside the `data` without defining additional global variables.\\n\\nThe following YAML output can be obtained by executing the above KCL code:\\n\\n```yaml\\ndata:\\n  name: app-name\\n  metadata:\\n    name: app-name\\n```\\n\\nHere is a more complex example:\\n\\n```python\\nname = \\"global-name\\"\\nmetadata = {\\n    name = \\"metadata-name\\"\\n    labels = {\\n        \\"app.kubernetes.io/name\\" = name  # Directly reference `metadata.name`\\n        \\"app.kubernetes.io/instance\\" = name  # Directly reference `metadata.name`\\n    }\\n}\\ndata = {\\n    name = name  # Reference the global variable `name`\\n    metadata = metadata  # Reference global variables `metadata`\\n    spec.template.metadata.name = metadata.name  # Reference `metadata` variables inside `data`.\\n}\\n```\\n\\nThe following YAML output can be obtained by executing the above code:\\n\\n```yaml\\nname: global-name\\nmetadata:\\n  name: metadata-name\\n  labels:\\n    app.kubernetes.io/name: metadata-name\\n    app.kubernetes.io/instance: metadata-name\\ndata:\\n  name: global-name\\n  metadata:\\n    name: metadata-name\\n    labels:\\n      app.kubernetes.io/name: metadata-name\\n      app.kubernetes.io/instance: metadata-name\\n  spec:\\n    template:\\n      metadata:\\n        name: metadata-name\\n```\\n\\n> \u26a0\ufe0f Note: The current KCL version does not support the backward reference of the internal attributes of the configuration block and the direct reference of global variables by skipping the internal scope. The referenced attributes need to be written in front of the configuration reference.\\n\\n### New Language Features\\n\\n#### Index Formatting of String Format Member function\\n\\nAfter KCL v0.4.5, KCL supports the use of the index tag style format `<format_ele_index>[<index_or_key>]` in the `{}` format block for KCL variables of list and dictionary types similar to the Python language.\\n\\n+ `<format_ele_index>` indicates the index that is needed to serialize list and dictionary-type elements.\\n+ `<index_or_key>` indicates the list sub-element index or dictionary sub-element key value of the corresponding list and dictionary type element.\\n\\nFor example, for the following KCL code\\n\\n```python\\n# 0[0] means taking the 0th element of [\\"Hello\\", \\"World\\"]: \\"Hello\\"\\n# 0[1] means taking the 1th element of [\\"Hello\\", \\"World\\"]: \\"\\"World\\"\\nlistIndexFormat = \\"{0[0]}{0[1]}\\".format([\\"Hello\\", \\"World\\"])\\n# 0[0] means taking the 0th element of [\\"0\\", \\"1\\"]: \\"0\\"\\n# 1[Hello] means taking {\\"Hello\\": \\"World\\"} dictionary element whose key value is Hello: \\"World\\"\\ndictIndexFormat = \\"0{0[0]}, 1{0[1]}, Hello{1[Hello]}\\".format([\\"0\\", \\"1\\"], {\\"Hello\\": \\"World\\"})\\n```\\n\\nThe following YAML output can be obtained by executing the above code:\\n\\n```yaml\\nlistIndexFormat: HelloWorld\\ndictIndexFormat: \\"00, 11, HelloWorld\\"\\n```\\n\\n### KCL Playground\\n\\nIn this update, we have updated the version of the KCL playground and support the automatic compilation and formatting of KCL code. You can visit the [KCL website](https://kcl-lang.io/) and click the playground button to experience it.\\n\\n![](/img/blog/2023-02-27-kcl-0.4.5-release-blog/kcl-website-playground.png)\\n\\n![](/img/blog/2023-02-27-kcl-0.4.5-release-blog/kcl-playground.png)\\n\\nIn the subsequent KCL versions, we will continue to update the KCL playground to support more capabilities, such as KCL version selection and code sharing.\\n\\n### More Platforms and Download Methods for KCL\\n\\n#### Windows\\n\\nKCL Windows binary version can now be downloaded from [Github](https://github.com/KusionStack/KCLVM/releases/) manually. After the download, add `{install_location}\\\\kclvm\\\\bin` to the environment variable `PATH`.\\n\\n```powershell\\n$env:PATH += \\";{install-location}\\\\kclvm\\\\bin;\\"\\n```\\n\\nIn addition, you can also install KCL through the Powershell script shown below:\\n\\n```powershell\\npowershell -Command \\"iwr -useb https://kcl-lang.io/script/install.ps1 | iex\\"\\n```\\n\\nWe will support more Windows package management download methods in the future, such as `Scoop`.\\n\\n#### More Download Methods\\n\\nIn this version update, we support more KCL download methods, including scripts, Python, Go, Homebrew, and Docker one-click installation. For more details, please refer to [KCL Download and Installation](https://kcl-lang.io/docs/user_docs/getting-started/install), we will support more KCL installation methods in the future.\\n\\n> \u26a0\ufe0f Note: For all the above operating systems and installation methods, if you want to use [KCL Python plug-in](https://kcl-lang.io/docs/reference/plugin/overview), you need to ensure that Python 3.7+ is installed and add the python3 command to your PATH environment variable.\\n\\n## Bugfix\\n\\n### The configuration merge order is incorrect when the right value of a non-configured expression exists\\n\\n```python\\nschema Resource:\\n    cpu: int\\n    memory: str\\n\\nschema Config:\\n    resource: Resource\\n\\nr = Resource {\\n    cpu = 4\\n    memory = \\"8Gi\\"\\n}\\n\\nconfig: Config {\\n    resource: Resource {\\n        cpu = 2\\n        memory = \\"4Gi\\"\\n    }\\n}\\n\\nconfig: Config {\\n    resource: r\\n}\\n```\\n\\nBefore KCL v0.4.5, executing the above code (main.k) will get unexpected configuration values because the KCL compiler incorrectly optimized the following form of equivalent merge configuration blocks:\\n\\n```python3\\nconfig: Config {\\n    resource: r\\n    resource: Resource {\\n        cpu = 2\\n        memory = \\"4Gi\\"\\n    }\\n}\\n```\\n\\nAfter KCL v0.4.5, the incorrect configuration of the merge order is corrected. You can execute `main.k` and obtain the expected YAML output:\\n\\n```yaml\\nr:\\n  cpu: 4\\n  memory: 8Gi\\nconfig:\\n  resource:\\n    cpu: 4\\n    memory: 8Gi\\n```\\n\\nFor more information, see [KCL Issue #422](https://github.com/KusionStack/KCLVM/issues/422).\\n\\n### Configure if expression type mismatch error optimization\\n\\n```python\\nconfig: {\\"A\\"|\\"B\\": int} = {\\n    if True:\\n        A = \\"2\\"\\n}\\n```\\n\\nBefore KCL v0.4.5, for the configuration if expression, executing the above code will get the expected configuration value, resulting in the type unsoundness problem, because the KCL compiler incorrectly checks that the value `\\"2\\"` of the `A` attribute does not match the declared type `int`. After the KCL v0.4.5, this problem has been corrected. You can execute the above code to obtain the expected type mismatch error:\\n\\n```stderr\\nKCL Compile Error[E2G22] : The type got is inconsistent with the type expected\\n---\x3e File main.k:1:1\\n1 |config: {\\"A\\"|\\"B\\": int} = {\\n 1 ^  -> got {str(A):str(2)}\\nexpect {str(A)|str(B):int}, got {str(A):str(2)}\\n```\\n\\nFor more information, see [KCL Issue #389](https://github.com/KusionStack/KCLVM/issues/389).\\n\\n### Rule statement validation does not work\\n\\nIn previous KCL versions, when the following rule code is used (main.k), the constraint code of `ServiceCheckRule` will not take effect.\\n\\n```python\\nprotocol KubeResourceProtocol:\\n    svc: Service\\n\\nschema Service:\\n    name: str\\n\\nrule ServiceCheckRule for KubeResourceProtocol:\\n    svc.name != \\"name\\"\\n\\nsvc = Service {\\n    name = \\"name\\"\\n}\\n\\nServiceCheckRule {\\n    svc = svc\\n}\\n```\\n\\nAfter the improvement, we execute the above code and get an accurate validation failure error:\\n\\n```stderr\\nKCL Runtime Error[E3B17] : Schema check is failed to check condition\\n---\x3e File main.k:14\\n14 |ServiceCheckRule { -> Instance check failed\\n    ---\x3e File main.k:8\\n    8 |    svc.name != \\"name\\" -> Check failed on the condition\\nCheck failed on check conditions\\n```\\n\\n### Configuration block attribute type inference optimization\\n\\n```python\\nschema Id:\\n    id?: int = 1\\n\\nschema Config:\\n    data?: {\\"A\\"|\\"B\\": Id}\\n\\nc = Config {\\n    data = {\\n        A = Id()  # Before v0.4.5, we will get a type mismatch error here.\\n        B = Id()\\n    }\\n}\\n```\\n\\nBefore KCL v0.4.5, executing the above code would result in an unexpected type mismatch, because the KCL compiler incorrectly deduced the type of the `c.data.A` attribute to the `str` type, resulting in a mismatch error with the string literal union type `\\"A\\"|\\"B\\"`. After KCL v0.4.5 was updated, this problem was corrected, and the expected YAML output could be obtained by executing the above code:\\n\\n```yaml\\nc:\\n  data:\\n    A:\\n      id: 1\\n    B:\\n      id: 1\\n```\\n\\n### Assignment statement uses schema type annotation error optimization\\n\\n```python\\nschema Foo:\\n    foo: int\\n\\nschema Bar:\\n    bar: int\\n\\nfoo: Foo = Bar {  # Before v0.4.5, we will get a runtime type mismatch error here\\n    bar: 1\\n}\\n```\\n\\nBefore KCL v0.4.5, executing the above code will result in a runtime type mismatch error. After the version is updated, this type mismatch error will be optimized to compile time, and the error will be moved to the left to find this type of error earlier.\\n\\n### Error on KCL module type with the ?. operator\\n\\n```python\\nimport math\\n\\ndata = math?.log(10)  # Before v0.4.5, we will get an unexpected \'math is not defined\' error here\\n```\\n\\nBefore KCL v0.4.5, executing the above code will result in an unexpected undefined variable error because the KCL compiler does not correctly handle the `math` module type and the `?.` operators are used in combination. After KCL v0.4.5, such issues are fixed.\\n\\n## Other Updates and Issues\\n\\nFor more updates and bug fixes, see [here](https://github.com/KusionStack/KCLVM/milestone/3)\\n\\n## Documents\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.3, v0.4.4, and v0.4.5 versions are supported.\\n\\n![](/img/blog/2023-02-27-kcl-0.4.5-release-blog/kcl-website-doc-version.png)\\n\\n## Community\\n\\n+ Two external contributors @thinkrapido and @Rishav1707 have participated in the KCL community, thank them for their enthusiasm and active participation in contributing.\\n+ Thank @Rishav1707 for establishing the Rust version of [kcl-loader-rs](https://github.com/i-think-rapido/kcl-loader-rs) sub-project based on KCL, which supports the automatic generation of Rust structure according to the schema and configuration definition in the KCL file and the deserialization function from KCL value to Rust structure value.\\n\\n## Next\\n\\nIt is expected that in the middle of April 2023, we will release **KCL v0.4.6**. The expected key evolution includes:\\n\\n+ KCL language is further improved for convenience, the user interface is continuously optimized and experience is improved, user support and pain points are solved.\\n+ A new version of the KCL language server and [VSCode language plug-in](https://github.com/KusionStack/vscode-kcl), the performance is expected to increase by **20 times**, and it is expected to support core basic capabilities such as code warning and error wavy line prompt, jump, reference search, etc.\\n+ Continuously improve the language ability for the pain points of Kubernetes Manifests configuration management scenarios. For example, design and provide the [Helm](https://github.com/helm/helm) KCL Schema plug-in and provide the KCL SDK for the [kpt](https://github.com/GoogleContainerTools/kpt) tool.\\n+ [KCL package management tool called KPM](https://github.com/KusionStack/kpm) release. It is expected to support Git repo code dependency configuration and update, code download, and other basic capabilities.\\n+ [KCL Playground](https://github.com/KusionStack/kcl-playground): Support code sharing and KCL version selection.\\n+ [KCL Go SDK](https://github.com/KusionStack/kclvm-go): More capability support such as supporting the bidirectional conversion of the KCL schema and Go structure\\n+ [KCL Python SDK](https://github.com/KusionStack/kclvm-py): More capability support.\\n\\nFor more details, please refer to [KCL v0.4.6 Milestone](https://github.com/KusionStack/KCLVM/milestone/4)\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/KusionStack/KCLVM)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/KusionStack/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-osdt-meeting","metadata":{"permalink":"/blog/2022-kcl-osdt-meeting","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2022-12-10-kcl-osdt-meeting/index.md","source":"@site/blog/2022-12-10-kcl-osdt-meeting/index.md","title":"KCL Introduction on OSDT 2022 Meeting","description":"Download PDF","date":"2022-12-10T00:00:00.000Z","formattedDate":"December 10, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"},{"label":"Policy","permalink":"/blog/tags/policy"}],"readingTime":0.01,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-osdt-meeting","title":"KCL Introduction on OSDT 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration","Policy"]},"prevItem":{"title":"KCL v0.4.5 Release Blog","permalink":"/blog/2022-kcl-0.4.5-release-blog"},"nextItem":{"title":"KCL v0.4.4 Release Blog","permalink":"/blog/2022-kcl-0.4.4-release-blog"}},"content":"[Download PDF](https://kcl-lang.github.io/talks/kcl-osdt2022.pdf)"},{"id":"2022-kcl-0.4.4-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.4-release-blog","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2022-12-06-kcl-0.4.4-release-blog/index.md","source":"@site/blog/2022-12-06-kcl-0.4.4-release-blog/index.md","title":"KCL v0.4.4 Release Blog","description":"The KCL team is pleased to announce that v0.4.4 is now available! This release mainly adds the ability to customize YAML manifests output for KCL. Users can customize the style of YAML output by writing code and calling system functions without understanding the complex schema settings semantics. In addition, this release provides the latest KCL Python SDK, which can be used for Python users to directly integrate KCL. At the same time, we have greatly reduced the size of the KCL installation package. The average installation package size has been reduced to one-fifth of that of the previous version. It also includes a number of compiler error message optimization and bug fix. You can visit the KCL release page to get more detailed release information and KCL binary download link.","date":"2022-12-06T00:00:00.000Z","formattedDate":"December 6, 2022","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"KusionStack","permalink":"/blog/tags/kusion-stack"},{"label":"Kusion","permalink":"/blog/tags/kusion"}],"readingTime":6.325,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.4-release-blog","title":"KCL v0.4.4 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL","KusionStack","Kusion"]},"prevItem":{"title":"KCL Introduction on OSDT 2022 Meeting","permalink":"/blog/2022-kcl-osdt-meeting"},"nextItem":{"title":"40x Faster! We rewrote our project with Rust","permalink":"/blog/2022-kcl-rewrite-with-rust"}},"content":"The KCL team is pleased to announce that v0.4.4 is now available! This release mainly adds the ability to customize YAML manifests output for KCL. Users can customize the style of YAML output by writing code and calling system functions without understanding the complex schema settings semantics. In addition, this release provides the latest [KCL Python SDK](https://github.com/KusionStack/kclvm-py), which can be used for Python users to directly integrate KCL. At the same time, we have greatly reduced the size of the KCL installation package. The average installation package size has been reduced to one-fifth of that of the previous version. It also includes a number of compiler error message optimization and bug fix. You can visit the [KCL release page](https://github.com/KusionStack/KCLVM/releases/tag/v0.4.4-alpha.2) to get more detailed release information and KCL binary download link.\\n\\n## Background\\n\\nKCL is an open-source constraint-based record and functional language. KCL improves the writing of a large number of complex configurations through mature programming language technology and practice, and is committed to building better modularity, scalability and stability around configuration, simpler logic writing, fast automation and good ecological extensionality.\\n\\nThis blog will introduce the recent developments of KCL community to readers.\\n\\n## Features\\n\\n### Customize YAML Manifest Output\\n\\nIn previous KCL versions, the style of YAML output is hard coded in the KCL compiler, and users can set the `__settings__` meta attribute with different values to determine the YAML output style, which brings high complexity. Therefore, in version 0.4.4, we provide a system module function for developers to easily customize the YAML output style. The signature of this function is as follows:\\n\\n```python\\nmanifests.yaml_stream(values: [any], opts: {str:} = {\\n    sort_keys = False\\n    ignore_private = True\\n    ignore_none = False\\n    sep = \\"---\\"\\n})\\n```\\n\\nThis function is used to serialize the KCL object list into YAML output with the `---` separator. It has two parameters:\\n\\n+ `values` - A list of KCL objects\\n+ `opts` - The YAML serialization options\\n  + `sort_keys`: Whether to sort the serialized results in the dictionary order of attribute names (the default is `False`).\\n  + `ignore_private`: Whether to ignore the attribute output whose name starts with the character `_` (the default value is `True`).\\n  + `ignore_none`: Whether to ignore the attribute with the value of\' None \'(the default value is `False`).\\n  + `sep`: Set the separator between multiple YAML documents (the default value is `\\"---\\"`).\\n\\nHere\'s an example:\\n\\n```python\\nimport manifests\\n\\nschema Deployment:\\n    apiVersion: str = \\"v1\\"\\n    kind: str = \\"Deployment\\"\\n    metadata: {str:} = {\\n        name = \\"deploy\\"\\n    }\\n    spec: {str:} = {\\n        replica = 2\\n    }\\n\\nschema Service:\\n    apiVersion: str = \\"v1\\"\\n    kind: str = \\"Service\\"\\n    metadata: {str:} = {\\n         name = \\"svc\\"\\n    }\\n    spec: {str:} = {}    \\n        \\ndeployments = [Deployment {}, Deployment {}]\\nservices = [Service {}, Service {}]\\n\\nmanifests.yaml_stream(deployments + services)\\n```\\n\\nFirst, we use the `import` keyword to import the `manifests` module and define two deployment resources and two service resources. When we want to output these four resources in YAML stream format with `---` as the separator, we can put them into a KCL list and use the `manifests.yaml_stream` function pass it to the `values` parameter (if there is no special requirement, the `opts` parameter can generally use the default value). Finally, the YAML output is:\\n\\n```yaml\\napiVersion: v1\\nkind: Deployment\\nmetadata:\\n  name: deploy\\nspec:\\n  replica: 2\\n---\\napiVersion: v1\\nkind: Deployment\\nmetadata:\\n  name: deploy\\nspec:\\n  replica: 2\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: svc\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: svc\\n```\\n\\n> Note: The feature of schema `__settings__` meta attribute setting YAML output style can still be used in v0.4.4. We will remove this feature in KCL v0.4.6 after the next two minor versions are released.\\n\\nFor more information, see [https://github.com/KusionStack/KCLVM/issues/94](https://github.com/KusionStack/KCLVM/issues/94).\\n\\n### Python SDK\\n\\nIn addition to the existing [KCL Go SDK](https://github.com/KusionStack/kclvm-go), this release also adds the KCL Python SDK. Using the Python SDK requires that you have a local Python version higher than 3.7.3 and a local pip package management tool. You can use the following command to install and obtain helpful information.\\n\\n```bash\\n$ python3 -m pip install kclvm --user && python3 -m kclvm --help\\n```\\n\\n#### Command Line Tool\\n\\nPrepare a KCL file named `main.k`\\n\\n```python\\nname = \\"kcl\\"\\nage = 1\\n\\nschema Person:\\n    name: str = \\"kcl\\"\\n    age: int = 1\\n\\nx0 = Person {}\\nx1 = Person {\\n    age = 101\\n}\\n```\\n\\nExecute the following command and get the output:\\n\\n```bash\\n$ python3 -m kclvm hello.k\\nname: kcl\\nage: 1\\nx0:\\n  name: kcl\\n  age: 1\\nx1:\\n  name: kcl\\n  age: 101\\n```\\n\\n#### API\\n\\nIn addition, we can also execute KCL files through Python code.\\n\\nPrepare a KCL file named `main.py`\\n\\n```python\\nimport kclvm.program.exec as kclvm_exec\\nimport kclvm.vm.planner as planner\\n\\nprint(planner.plan(kclvm_exec.Run([\\"hello.k\\"]).filter_by_path_selector()))\\n```\\n\\nExecute the following command and get the output:\\n\\n```bash\\n$ python3 main.py\\nname: kcl\\nage: 1\\nx0:\\n  name: kcl\\n  age: 1\\nx1:\\n  name: kcl\\n  age: 101\\n```\\n\\nYou can see that the same output can be obtained through command line tools and APIs.\\n\\nAt present, the KCL Python SDK is still in the early preview version. The KCL team will continue to update and provide more functions in the future. For more information, see [https://github.com/KusionStack/kclvm-py](https://github.com/KusionStack/kclvm-py)\\n\\n## Installation Size Optimization\\n\\nIn the new KCL version, we split the built-in Python 3 of KCL, reducing the average size of the KCL binary compression package from 200M to 35M. Users can download and use KCL faster, and the Python plugin becomes an option. If you want to enable the KCL Python plugin, an additional requirement is that you have Python and pip package management tools that are higher than 3.7.3. For more details, please see [https://github.com/KusionStack/kcl-plugin](https://github.com/KusionStack/kcl-plugin)\\n\\n## Bugfix\\n\\n### Function Call Error Information Optimization\\n\\nIn version 0.4.4, KCL optimizes the output of error messages when the number of function arguments does not match, and supports the display of function names and the number of argument mismatches\\n\\n```python\\nschema Foo[x: int]:\\n    bar?: int = x\\n\\nf = lambda x {\\n    x + 1\\n}\\n\\nfoo = Foo(1,2,3)  # Error: \\"Foo\\" takes 1 positional argument but 3 were given\\nf(1,2)  # Error: \\"f\\" takes 1 positional argument but 2 were given\\n```\\n\\nFor more information, see [https://github.com/KusionStack/KCLVM/issues/299](https://github.com/KusionStack/KCLVM/issues/299)\\n\\n### Formatting Error of Interpolated Three Quote String\\n\\nIn previous KCL versions, formatting the following code would incorrectly convert the three quotation marks with string interpolation into single quotation marks and cause compilation errors. In version 0.4.4, we fixed the issue.\\n\\n```python\\n# Before KCL v0.4.4, variable \\"bar\\" will be formatted as:\\n#\\n# foo = 1\\n# bar = \\"\\n# ${foo}\\n# \\"\\nfoo = 1\\nbar = \\"\\"\\"\\n${foo}\\n\\"\\"\\"\\n```\\n\\nFor more information, see [https://github.com/KusionStack/KCLVM/issues/294](https://github.com/KusionStack/KCLVM/issues/294)\\n\\n### Other Issues\\n\\nFor more issues, see [https://github.com/KusionStack/KCLVM/milestone/2?closed=1](https://github.com/KusionStack/KCLVM/milestone/2?closed=1)\\n\\n## Documents\\n\\n[KCL website](https://kcl-lang.github.io/) preliminary establishment and improvement of Kubernetes scenarios [related documents](https://kcl-lang.github.io/docs/user_docs/guides/working-with-k8s/).\\n\\nFor more information, see [https://kcl-lang.github.io/](https://kcl-lang.github.io/)\\n\\n## Community\\n\\nThree external contributors @my-vegetable-has-exploded, @possible-fqz, @orangebees have participated in the KCL community, thank them for their enthusiasm and active participation in contributing.\\n\\n## Next\\n\\nIt is estimated that by the end of January 2023, we will release KCL v0.4.5, and the key evolution is expected to include\\n\\n+ Continuous optimization of the KCL user interface, improvement of experience and user pain points.\\n+ More scenarios and ecology integration, such as Kubernetes and CI/CD Pipeline scenarios.\\n+ KCL Windows version support.\\n+ KCL package management tool `kpm` release.\\n+ The new version of KCL playground.\\n\\nFor more information, see [KCL v0.4.5 Milestone](https://github.com/KusionStack/KCLVM/milestone/3).\\n\\n## FAQ\\n\\nFor more information, see [https://kcl-lang.github.io/docs/user_docs/support/](https://kcl-lang.github.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\n+ [KCL Website](https://kcl-lang.github.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/KusionStack/KCLVM)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/KusionStack/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-rewrite-with-rust","metadata":{"permalink":"/blog/2022-kcl-rewrite-with-rust","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2022-11-29-kcl-rewrite-with-rust/index.md","source":"@site/blog/2022-11-29-kcl-rewrite-with-rust/index.md","title":"40x Faster! We rewrote our project with Rust","description":"Introduction","date":"2022-11-29T00:00:00.000Z","formattedDate":"November 29, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Rust","permalink":"/blog/tags/rust"},{"label":"Performance","permalink":"/blog/tags/performance"},{"label":"Programming Language","permalink":"/blog/tags/programming-language"},{"label":"Compiler","permalink":"/blog/tags/compiler"}],"readingTime":9.745,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-rewrite-with-rust","title":"40x Faster! We rewrote our project with Rust","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Rust","Performance","Programming Language","Compiler"]},"prevItem":{"title":"KCL v0.4.4 Release Blog","permalink":"/blog/2022-kcl-0.4.4-release-blog"},"nextItem":{"title":"KCL Introduction on SETTA 2022 Meeting","permalink":"/blog/2022-kcl-setta-meeting"}},"content":"## Introduction\\n\\nRust has quietly become one of the most popular programming languages. As an popular emerging system language, Rust has many great characteristics, such as its memory security mechanism, performance close to that of C/C++, an excellent development community and helpful documentation, tool chains and IDEs. In this blog, we will introduce the process of using Rust for a rewrite and gradually implementing the production environment, as well as the reasons for choosing Rust, any issues we have encountered, and the results of the rewrite.\\n\\nThe project we are using Rust to develop is called [KCL](https://github.com/KusionStack/KCLVM). KCL is an open-source, constraint-based record and functional programming language. It leverages mature programming language technology and practice to facilitate the writing of many complex configurations. KCL is designed to improve modularity, scalability, and stability around configuration, simplify logic writing, speed up automation and create a thriving extension ecosystem. To learn more about specific KCL usage scenarios, please refer to the [KCL website](https://kcl-lang.github.io/). This blog will not go into too much detail about that.\\n\\nKCL was written in Python before. After carefully evaluating the user experience, performance and stability, we decided to rewrite KCL in Rust, and the following benefits were obtained:\\n\\n+ Rust\'s powerful compilation checks and error handling led to fewer bugs.\\n+ There was a 66% improvement in end-to-end compilation and execution performance.\\n+ The language front-end parser performance improved by up to 20 times.\\n+ The language semantic analyzer performance improved by up to 40 times.\\n+ The average memory usage of the language compiler during compilation was roughly half of the original Python version.\\n\\n## What problems have we encountered\\n\\nThe compiler, build system or runtime uses Rust to do similar things in technology like projects of the same type in the community [deno](https://github.com/denoland/deno), [swc](https://github.com/swc-project/swc), [turbopack](https://github.com/vercel/turbo), [rustc](https://github.com/rust-lang/rust). We used Rust to completely build the front, middle and runtime of the compiler, and achieved some results, but we did not do this about a year ago.\\n\\nA year ago, we used Python to build the entire KCL compiler implementation, which initially ran well due to Python\u2019s ease of use, rich ecosystem, and the team\'s high research and development efficiency. However, as the codebase and number of engineers grew, code maintenance became increasingly difficult. To counter this, we enforced the usage of Python type annotations and employed stricter linting tools, as well as achieving >90% code test coverage. Yet, runtime errors such as empty Python objects and missing attributes remained, and refactoring had to be done with caution.\\n\\nAs KCL users are mostly developers, any mishaps in the language or compiler internals were unacceptable, leading to a range of issues with user experience. Furthermore, programs written in Python had slow startup times, and their performance did not meet the efficiency demands of automating the online compilation and execution. Therefore, a compiler written in Python was unable to adequately meet use requirements.\\n\\nConsequently, we decided to rewrite KCL in Rust to not only improve user experience, but to also benefit from Rust\u2019s powerful compilation checks and error handling. This led to a 66% improvement in end-to-end compilation and execution performance, as well as a 20- and 40-fold improvement in the language front-end and semantic analyser performance, respectively. The average memory usage of the compiler during compilation was also roughly halved.\\n\\n## Why use Rust\\n\\nWe chose Rust for the following reasons:\\n\\n+ We implemented a simple programming language stack virtual machine in Python, Go, and Rust and conducted a performance comparison, Rust was adopted under comprehensive consideration as Go and Rust had similar performance whereas Python had a large performance gap. The details of the stack virtual machine code implemented by the three languages are here: [https://github.com/Peefy/StackMachine](https://github.com/Peefy/StackMachine).\\n+ Rust has been widely utilized for compilers or runtimes of programming languages, especially in front-end infrastructure projects, and is present in various fields such as infrastructure, database, search engine, network, cloud-native, UI, and embedded systems, ensuring its feasibility and stability.\\n+ Considering that the subsequent project development will involve the direction of blockchain and smart contract, and a large number of blockchain and smart contract projects in the community are written by Rust.\\n+ Rust provides better performance and stability, making the system easier to maintain and more robust, while allowing developers to expose C APIs through FFI for multilingual use and expansion.\\n+ Rust\'s friendly support for Web Assembly (WASM) is extremely beneficial for the development of blockchain and smart contract projects.\\n\\nBased on the above reasons, we chose Rust instead of Go. In the whole rewriting process, we found that Rust\'s comprehensive quality is impressive because it not only provides high performance but also a sufficient abstraction, although there is some cost in certain language features such as lifetime. Nevertheless, its ecology is not as rich as other languages.\\n\\n## What are the difficulties in using Rust\\n\\nAlthough we decided to rewrite the entire KCL project with Rust, most team members have no experience in writing a certain project with Rust, and I has only learned [The Rust Programming Language](https://doc.rust-lang.org/book/). I vaguely remember that I gave up when I learned about intelligent pointers such as `Rc` and `RefCell`. At that time, I didn\'t expect that there would be anything similar to C++ in Rust.\\n\\nThe risk of utilizing Rust is mainly the expense of learning the language, which is evidently discussed in a multitude of Rust blogs. Seeing that the overall structure of the KCL project had not been altered considerably, and some modules\' designs and their code had been greatly improved for Rust, the entire rewrite was accomplished through a process of mastering Rust whilst practicing. When we set out to use Rust to create the whole project, time was spent on knowledge querying, compilation and debugging. As the project advanced, however, the main challenges that arose from utilizing Rust were mainly the transformation of our mindsets, as well as the efficiency of development.\\n\\n### Mental transformation\\n\\nFirst of all, the syntax and semantics of Rust well absorb and integrate the concepts related to the type system in functional programming, such as the Abstract Algebraic Type (ADT). In addition, there is no concept related to \\"inheritance\\" in Rust. If you can\'t understand it well, even ordinary structure definitions in other languages may take a lot of time in Rust. For example, the following Python code may be defined like this in Rust.\\n\\n+ Python\\n\\n```python\\nfrom dataclasses import dataclass\\n\\nclass KCLObject:\\n    pass\\n\\n@dataclass\\nclass KCLIntObject(KCLObject):\\n    value: int\\n\\n@dataclass\\nclass KCLFloatObject(KCLObject):\\n    value: float\\n```\\n\\n+ Rust\\n\\n```rust\\nenum KCLObject {\\n    Int(u64),\\n    Float(f64),\\n}\\n```\\n\\nOf course, more time is spent fighting against the error reports of the Rust compiler itself. The Rust compiler will often cause developers to \\"run into a wall\\", such as borrowing check errors. Especially for the KCL compiler, its core structure is the Abstract Syntax Tree (AST), which is a recursive and nested tree structure.\\n\\nIt is sometimes difficult to give consideration to the relationship between variable variability and borrowing check in Rust, Just like the scope structure `Scope` defined in KCL compiler, for scenarios with circular references, it is used to display the interdependence of data that needs to be aware of, while making extensive use of intelligent pointer structures commonly used in Rust such as `Rc`, `RefCell` and `Weak`.\\n\\n```rust\\n/// A Scope maintains a set of objects and links to its containing\\n/// (parent) and contained (children) scopes. Objects may be inserted\\n/// and looked up by name. The zero value for Scope is a ready-to-use\\n/// empty scope.\\n#[derive(Clone, Debug)]\\npub struct Scope {\\n    /// The parent scope.\\n    pub parent: Option<Weak<RefCell<Scope>>>,\\n    /// The child scope list.\\n    pub children: Vec<Rc<RefCell<Scope>>>,\\n    /// The scope object mapping with its name.\\n    pub elems: IndexMap<String, Rc<RefCell<ScopeObject>>>,\\n    /// The scope start position.\\n    pub start: Position,\\n    /// The scope end position.\\n    pub end: Position,\\n    /// The scope kind.\\n    pub kind: ScopeKind,\\n}\\n```\\n\\n### Development efficiency\\n\\nThe efficiency of utilizing Rust may appear low at first, but it will become substantially high upon gaining familiarity with it. Initially, if the team members have not been exposed to concepts such as functional programming and related coding practices, the development speed will be much slower than that of languages such as Python, Go, and Java. Nevertheless, once they become familiarized with the conventional methods and best practices of the Rust standard library, as well as the common fixes for Rust compiler errors, the development efficiency will be dramatically boosted, and they will be able to compose high-quality, safe, and efficient code naturally.\\n\\nFor instance, I ran into a Rust lifetime error in the following code. After troubleshooting for a lengthy duration, it became apparent that the lifetime inconsistency was due to neglecting to label lifetime parameters. Additionally, Rust\u2019s lifetime is combined with concepts such as type system, scope, ownership, and borrowing inspection, resulting in a higher cost and complexity of understanding, with error reporting information often not as clear-cut as type errors. The lifetime inconsistency error reporting information can sometimes be somewhat inflexible, which may lead to a costly troubleshooting procedure. Of course, efficiency will be improved with increasing familiarity with the pertinent concepts.\\n\\n```rust\\nstruct Data<\'a> {\\n    b: &\'a u8,\\n}\\n\\n// func2 omit lifecycle parameters, and func2 does not.\\n// The lifecycle of func2 will be deduced as \'_ by the Rust compiler by default,\\n// which may lead to lifetime mismatch error.\\nimpl<\'a> Data<\'a> {\\n    fn func1(&self) -> Data<\'a> {Data { b: &0 }}\\n    fn func2(&self) -> Data {Data { b: &0 }}\\n}\\n```\\n\\n## Rewrite revenue ratio using Rust\\n\\nAfter spending several months using Rust to completely rewrite and steadily deploy the KCL project into a production environment, we have looked back on the whole process and found it highly rewarding.\\n\\nFrom a technical point of view, the rewrite process not only trained us to quickly learn a new programming language and its associated knowledge, but it also enabled us to put them into practice. The whole rewrite process also made us reflect on the unrational design of the KCL compiler and modify it accordingly. For a programming language, this is a long-cycle project. We have learned that such a compiler system should be more stable, and secure, with legible code, fewer bugs, and better performance.\\n\\nAlthough not all modules achieved a 40-fold improvement in performance (due to memory deep copy operations being the main bottleneck of some modules, such as the KCL runtime), I still think it is particularly beneficial. With enough experience in Rust, mental and development efficiency are no longer limiting factors.\\n\\nOverall, although our team encountered obstacles while using Rust to rewrite the KCL project, we eventually succeeded. We have acquired invaluable knowledge and experience in the process, which will be immensely beneficial in the future.\\n\\n## Conclusion\\n\\nI personally think that the most important thing after using Rust to rewrite the project is whether I have learned a new programming language or whether Rust is very popular and we have written many fancy codes using Rust. The stability, startup-time, and automation-efficiency of the KCL compiler and language is significantly improved. Furthermore, with Rust\'s non-GC, high-performance, improved error handling, memory management, and lack of abstraction, the performance of KCL improves substantially as compared to other languages in similar fields. In short, the users of KCL are the biggest beneficiaries of the improvements made possible by Rust.\\n\\nIf you are interested in the KCL project, wish to use KCL for your personal use cases, or want to use Rust to participate in an open-source project, welcome to visit [https://github.com/KusionStack/community](https://github.com/KusionStack/community) to join our community to participate in discussion and co construction \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f\u3002\\n\\n## Reference\\n\\n+ https://github.com/KusionStack/KCLVM\\n+ https://github.com/Peefy/StackMachine\\n+ https://doc.rust-lang.org/book/\\n+ https://github.com/sunface/rust-course\\n+ https://www.influxdata.com/blog/rust-can-be-difficult-to-learn-and-frustrating-but-its-also-the-most-exciting-thing-in-software-development-in-a-long-time/"},{"id":"2022-kcl-setta-meeting","metadata":{"permalink":"/blog/2022-kcl-setta-meeting","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2022-10-27-kcl-setta-meeting/index.md","source":"@site/blog/2022-10-27-kcl-setta-meeting/index.md","title":"KCL Introduction on SETTA 2022 Meeting","description":"Download PDF","date":"2022-10-27T00:00:00.000Z","formattedDate":"October 27, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":0.01,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-setta-meeting","title":"KCL Introduction on SETTA 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"40x Faster! We rewrote our project with Rust","permalink":"/blog/2022-kcl-rewrite-with-rust"},"nextItem":{"title":"KCL papers were accepted by SETTA 2022","permalink":"/blog/2022-kcl-setta-paper"}},"content":"[Download PDF](https://kcl-lang.github.io/talks/kcl-setta2022.pdf)"},{"id":"2022-kcl-setta-paper","metadata":{"permalink":"/blog/2022-kcl-setta-paper","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2022-10-13-kcl-setta-paper/index.md","source":"@site/blog/2022-10-13-kcl-setta-paper/index.md","title":"KCL papers were accepted by SETTA 2022","description":"Recently, the KCL paper written by the team members was accepted by SETTA 2022 International Conference.","date":"2022-10-13T00:00:00.000Z","formattedDate":"October 13, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":1.03,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-setta-paper","title":"KCL papers were accepted by SETTA 2022","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"KCL Introduction on SETTA 2022 Meeting","permalink":"/blog/2022-kcl-setta-meeting"},"nextItem":{"title":"The Landscape of Declarative Configuration","permalink":"/blog/2022-declarative-config-overview"}},"content":"Recently, the KCL paper written by the team members was accepted by SETTA 2022 International Conference.\\n\\n![](/img/docs/events/2022/kcl_paper_setta.png)\\n\\nThe purpose of the Symposium on Dependable Software Engineering (SETTA) symposium is to bring international researchers together to exchange research results and ideas on bridging the gap between formal methods and software engineering. This is for instance reflected by the challenges in applying formal techniques and tools to engineering large-scale systems such as Cyber-Physical Systems (CPS), Internet-of-Things (IoT), Enterprise Systems, Cloud-Based Systems, and so forth.\\n\\nThe title of the paper \\"KCL: A Declarative Language for Large scale Configuration and Policy Management\\". The core contribution of this paper is to propose the KCL declarative language, development mechanism, and consistent workflow. Through the language model and constraint capabilities, we can improve the large-scale efficiency and liberate multi-team collaborative productivity of operational development and operation systematically while ensuring stability for large-scale configuration and policy management.\\n\\nIn addition, SETTA 2022 will hold an online conference from October 27 to October 28 (Beijing time), at which time the details of KCL papers will be shared and welcome to join [KCL Community](https://github.com/KusionStack/community). For details of SETTA 2022 meeting agenda, please refer to https://lcs.ios.ac.cn/setta2022/program.php\\n\\nNote: KCL has been open-source in Github. Visit https://github.com/KusionStack/KCLVM for more information."},{"id":"2022-declarative-config-overview","metadata":{"permalink":"/blog/2022-declarative-config-overview","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2022-09-15-declarative-config-overview/index.md","source":"@site/blog/2022-09-15-declarative-config-overview/index.md","title":"The Landscape of Declarative Configuration","description":"The blog is only used to clarify the landscape of declarative configuration, KCL core concept and features, as well as the comparison with other configuration languages.","date":"2022-09-15T00:00:00.000Z","formattedDate":"September 15, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":26.975,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-declarative-config-overview","title":"The Landscape of Declarative Configuration","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"KCL papers were accepted by SETTA 2022","permalink":"/blog/2022-kcl-setta-paper"},"nextItem":{"title":"KCL Introduction on GIAC 2021 Meeting","permalink":"/blog/2021-kcl-intro"}},"content":"The blog is only used to clarify the landscape of declarative configuration, [KCL](https://github.com/KusionStack/KCLVM) core concept and features, as well as the comparison with other configuration languages.\\n\\n## 1. The Landscape of Declarative Configuration\\n\\n### 1.1 Importance of Configuration\\n\\n- There are thousands of configuration updates every day because the software development and the configuration itself are gradually evolving, which has a high demand for large-scale efficiency.\\n  - **The configuration is updated more frequently**: The evolving business requirements, infrastructure requirements and other factors mean that the system needs to change constantly, and the configuration provides a low-cost way to change the system functions.\\n  - **The configuration scale is getting larger**: A configuration is often distributed to different cloud sites, different tenants, different environments, etc.\\n  - **Wide configuration scenarios**: Application, database, network, monitoring, etc.\\n  - **Various configuration formats**: JSON, YAML, XML, TOML, various configuration templates such as Java Velocity, Go Template, etc.\\n- The stability of the configuration is crucial. One of the main reasons for system errors is that a large number of engineers frequently update the configuration. Table 1 shows several system error events caused by configuration.\\n\\n| Time | Event |\\n| --- | --- |\\n| 2021.07 | The Bilibili website in China went down because SLB Lua configuration code fell into an infinite loop with calculation errors |\\n| 2021.10 | KT Company in South Korea suffers major network interruption nationwide due to wrong routing configuration |\\n\\nTable 1 System error events caused by configuration.\\n\\n### 1.2 Classification of Declarative Configuration\\n\\nThe cloud-native era has brought about rapid technological development, with a large number of declarative configurations. As shown in Fig. 1, declarative configuration can be generally divided into the following ways.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/01-declarative-config.png)\\n\\nFig. 1: Classification of declarative configuration.\\n\\n#### 1.2.1 Structured K-V\\n\\nStructured K-V meets the minimum data declaration requirements (int, string, list, dict, etc.). Declarative API meets the development demands of X as Data with the rapid development and application of cloud-native technology. Machine-readable and writable, human-readable.\\n\\n- Pros.\\n  - Simple syntax, easy to write and read.\\n  - Rich multilingual APIs.\\n  - Various path tools for data query, such as XPath, JsonPath, etc.\\n- Cons.\\n  - Too much redundant information: when the configuration scale is large, it is difficult to maintain the configuration, because important configuration information is hidden in a large number of irrelevant repetitive data details.\\n  - Lack of functionality: constraint, complex logic, test, debug, abstraction, etc.\\n  - [Kustomize](https://kustomize.io/)\'s patches are basically by fixing several patch merge strategies\\n\\nRepresentative technologies of structured KV include:\\n\\n- JSON/YAML: It is very convenient for reading and automation, and has different languages API support.\\n- [Kustomize](https://kustomize.io/): It provides a solution to customize the Kubernetes resource base configuration and differential configuration without **template** and **DSL**. It does not solve the constraint problem itself, but needs to cooperate with a large number of additional tools to check constraints, such as [Kube-linter](https://github.com/stackrox/kube-linter)\u3001[Checkov](https://github.com/bridgecrewio/checkov). Fig. 2shows the typical working mode of Kustomize.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/02-kustomize.png)\\n\\nFig. 2: Typical working mode of Kustomize.\\n\\n#### 1.2.3 Templated K-V\\n\\nThe Templated KV has the capability of static configuration data and dynamic parameters, and can output different static configuration data with one template+dynamic parameters. The advantages and disadvantages are as follows:\\n\\n- Pros.\\n  - Simple configuration logic and loop support.\\n  - External dynamic parameter support.\\n- Cons.\\n  - It is easy to fall into the trap that all configurations are template parameters.\\n  - When the configuration scale becomes larger, it is difficult for developers and tools to maintain and analyze them.\\n\\nRepresentative technologies of templated KV include:\\n\\n- [Helm](https://helm.sh/): The package management tool of Kubernetesresources, which manages the configuration of Kubernetes resources through the configuration template. Fig. 3 shows a Helm Jekins Package ConfigMap configuration template. It can be seen that these templates are very short with simple logic. A series of resource configurations suitable forKubernetes basic components are installed through package management and additional configuration parameters. Compared with the simply templatedK-V, Helm provides template storage, reference and semantic version management capabilities. Compared with Kustomize, Helm is more suitable for managing external Charts but is not good at multi-environment and multi-tenant configuration management.\\n- Other configuration templates: Java Velocity, Go Template and other text template engines are very suitable for HTML writing templates. However,when used in configuration scenarios, they are difficult for developers and tools to maintain and analyze.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/03-helm.png)\\n\\nFig. 3: Helm Jekins Package ConfigMap configuration template.\\n\\n#### 1.2.3 Programmable K-V\\n\\n`Configuration as Code (CaC)` uses code to generate configuration, just like engineers only need to write advanced GPL code, rather than manually writing error-prone and difficult-to-understand server binary code.\\n\\n- Configuration changes are treated as seriously as code changes, and unit tests and integration tests can also be executed.\\n- Code modularization is a key reason why maintaining configuration code is easier than manually editing configuration files such as JSON/YAML.\\n\\n- Capability\\n  - Necessary programming language abilities (variable definitions, logical judgments, loops, assertions, etc.).\\n  - Necessary template capability, which supports the definition of data templates and the use of templates to obtain new configuration data.\\n  - Code modularity: structure definition and package management.\\n  - Machine-readable and writable, human-readable and writable.\\n- Pros.\\n  - Necessary programming ability.\\n  - Code modularization and abstraction.\\n  - Configuration template and override ability.\\n- Cons.\\n  - Insufficient type check.\\n  - Insufficient constraint capacity.\\n  - Many runtime errors.\\n\\nRepresentative technologies of programmable KV include:\\n\\n- [GCL](https://github.com/rix0rrr/gcl): A declarative configuration programming language implemented in Python provides the necessary language capabilities to support template abstraction. However, the compiler itself is written in Python, and the language itself is interpreted and executed. For large template instances (such as Kubernetes models), the performance is poor.\\n- [HCL](https://github.com/hashicorp/hcl): A Go implementation structured configuration language. The native syntax of HCL is inspired by libucl and nginx configurations. It is used to create a structured configuration language that is friendly to humans and machines, mainly for DevOps tools, server configurations, and resource configurations as a [Terraform language](https://www.terraform.io/language).\\n- [Jsonnet](https://github.com/google/jsonnet): A data template language implemented in C++, suitable for application and tool developers, can generate configuration data and organize, simplify and manage large configurations without side effects.\\n\\n#### 1.2.4 Typed K-V\\n\\n- Capability\\n  - Based on programmable K-V, typed K-V has more capabilities of type constraints.\\n- Pros.\\n  - The configuration merge is completely idempotent, which naturally prevents configuration conflicts.\\n  - Rich constraint syntax for writing configuration.\\n  - Abstract the type and value constraints into the same form, which is simple to write.\\n  - Configuration order independent.\\n- Cons.\\n  - The concepts of graph merging and idempotent merging are complex, and the understanding cost is high.\\n  - The mixed definition of type and value improves the degree of abstraction and the cost of understanding. All constraints are checked at runtime, and there is a performance bottleneck for the large-scale configuration code.\\n  - It is difficult to implement multi-tenant and multi-environment scenarios that want to configure coverage and modification.\\n  - For constrained scenarios with conditions, the user interface for writing hybrid definitions of definition and verification is unfriendly.\\n\\nRepresentative technologies of typed KV include:\\n\\n- [CUE](https://github.com/cue-lang/cue): The core problem CUE solves is \\"type checking\\", which is mainly used in configuration constraint verification scenarios and simple cloud native configuration scenarios.\\n\\n#### 1.2.5 Modeled K-V\\n\\n- Pros.\\n  - High-level language modeling capability as the core description\\n    - Modeling\\n    - Immutability\\n    - Constraints\\n  - High scalability through automatic merge mechanism of isolated config blocks.\\n  - Writing and testing methods like a high-level programming language.\\n  - Machine-readable and writable, human-readable and writable.\\n- Cons.\\n  - The expansion of new models and ecological construction requires certain R&D costs\\n\\nRepresentative technologies of modeled KV include:\\n\\n- [KCL](https://github.com/KusionStack/KCLVM): A declarative configuration and policy programming language implemented by Rust, which improves the writing of a large number of complex configurations through mature programming language technology and practice, and is committed to building better modularity, scalability and stability around configuration, simpler logic writing, fast automation and good ecological extensionally. Fig. 4 shows a typical scenario of KCL writing application delivery configuration code.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/04-kcl-app-code.png)\\n\\nFig. 4: A typical scenario of KCL writing application delivery configuration code.\\n\\n### 1.3 Guidelines and Best Practices for Different Declarative Configurations\\n\\n- Configuration scale: For small-scale configuration scenarios, we can use YAML/JSON and other configurations, such as the simple configuration of the application itself and CI/CD configuration. In addition, for the requirements of multi-environment and multi-tenant in small-scale configuration scenarios, Kustomize\'s overlay capability can be used to implement operations such as merging and covering simple configurations.\\n\\n- The necessity of model abstraction and constraint: For large-scale configuration scenarios, especially for those with urgent needs for configuration model and O&M feature R&D and precipitation of multi-tenant and multi-environment, the K-V method of coding, typing and modeling can be used.\\n\\nIn addition, consider the use scenarios of different declarative configurations:\\n\\n- YAML is recommended if you need to write structured static K-V or use Kubernetes\' native tools.\\n- HCL is recommended if you want to use programming language convenience to remove boilerplate with good human readability, or if you are already a Terraform user.\\n- CUE is recommended if you want to use a type system to improve stability and maintain scalable configurations.\\n- KCL is recommended if you want types and modelings like a modern language, scalable configurations, in-house pure functions and rules, and production-ready performance and automation.\\n\\nDifferent from other languages of the same type in the community, KCL is a static strongly typed compilation language for application developers and adopts modern language design and technology.\\n\\n> Note that this blog will not discuss the general language used for writing configuration. The general language is usually overkill, that is, it goes far beyond the problems that need to be solved. There are various security problems in the general language, such as the ability boundary problem (starting local threads, accessing IO, network, code infinitive looping and other security risks). For example, in the music field, there are special notes to express music, which is convenient for learning and communication, It can not be expressed clearly in general language.\\n>\\n> In addition, because of its various styles of the general language, which has the cost of unified maintenance, management and automation. The general language is usually used to write the client runtime, which is a continuation of the server runtime. It is not suitable for writing configurations that are independent of the runtime, and it is compiled into binary and started from the process finally. Besides, the stability and scalability are not easy to control. However, the configuration language often be used to write data, which is combined with simple logic, and it describes the expected final result, which is then consumed by the compiler or engine.\\n\\n## 2. KCL Core Features and Use Cases\\n\\nThe core features of KCL are its **modeling** and **constraint** capabilities, and the basic functions of KCL revolve around the two core features. In addition, KCL follows the user-centric configuration concept to design its basic functions, which can be understood from two aspects:\\n\\n- **Domain model-centric configuration view**: With the rich features of KCL language and [KCL OpenAPI](https://kcl-lang.io/docs/tools/cli/openapi/) tools, we can directly integrate a wide range of well-designed models in the community into KCL (such as the K8s resource model). We can also design and implement our own KCL models or libraries according to different scenarios, forming a complete set of domain models for other configuration end users to use.\\n- **End user-centric configuration view**: With KCL\'s code encapsulation, abstraction and reuse capabilities, the model architecture can be further abstracted and simplified (for example, the K8s resource model is abstracted into an application-centered server model) to **minimize the end user configuration input**, simplify the user\'s configuration interface, and facilitate manual or automatic API modification.\\n\\nNo matter what configuration view is centered on, for configuration code, there are requirements for configuration data constraints, such as type constraints, required/optional constraints on configuration attributes, range constraints, and immutability constraints. This is also one of the core issues KCL is committed to solving. KCL mainly contains the core features shown in Fig. 5.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/05-kcl-core-feature.png)\\n\\nFig. 5: KCL core features.\\n\\n- **Easy-to-use**: Originated from high-level languages \u200b\u200bsuch as Python and Golang, incorporating functional language features with low side effects.\\n- **Well-designed**: Independent Spec-driven syntax, semantics, runtime and system modules design.\\n- **Quick modeling**: [Schema](https://kcl-lang.io/docs/reference/lang/tour#schema)-centric configuration types and modular abstraction.\\n- **Rich capabilities**: Configuration with type, logic and policy based on [Config](https://kcl-lang.io/docs/reference/lang/tour#config-operations), [Schema](https://kcl-lang.io/docs/reference/lang/tour#schema), [Lambda](https://kcl-lang.io/docs/reference/lang/tour#function), [Rule](https://kcl-lang.io/docs/reference/lang/tour#rule).\\n- **Stability**: Configuration stability built on [static type system](https://kcl-lang.io/docs/reference/lang/tour/#type-system), [constraints](https://kcl-lang.io/docs/reference/lang/tour/#validation), and [rules](https://kcl-lang.io/docs/reference/lang/tour#rule).\\n- **Scalability**: High scalability through [automatic merge mechanism](https://kcl-lang.io/docs/reference/lang/tour/#-operators-1) of isolated config blocks.\\n- **Fast automation**: Gradient automation scheme of [CRUD APIs](https://kcl-lang.io/docs/reference/lang/tour/#kcl-cli-variable-override), [multilingual SDKs](https://kcl-lang.io/docs/reference/xlang-api/overview), [language plugin](https://github.com/KusionStack/kcl-plugin)\\n- **High performance**: High compile time and runtime performance using Rust & C and [LLVM](https://llvm.org/), and support compilation to native code and [WASM](https://webassembly.org/).\\n- **API affinity**: Native support API ecological specifications such as [OpenAPI](https://github.com/KusionStack/kcl-openapi), Kubernetes CRD, Kubernetes YAML spec.\\n- **Development friendly**: Friendly development experiences with rich [language tools](https://kcl-lang.io/docs/tools/cli/kcl/) (Format, Lint, Test, Vet, Doc, etc.) and [IDE plugins](https://github.com/KusionStack/vscode-kcl).\\n- **Safety & maintainable**: Domain-oriented, no system-level functions such as native threads and IO, low noise and security risk, easy maintenance and governance.\\n- **Rich multi-language API**: Rich multilingual API: [Go](https://kcl-lang.io/docs/reference/xlang-api/go-api), [Python](https://kcl-lang.io/docs/reference/xlang-api/python-api) and [REST APIs](https://kcl-lang.io/docs/reference/xlang-api/rest-api) meet different scenarios and application use prelude.\\n- **Production-ready**: Widely used in production practice of platform engineering and automation at Ant Group.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/06-kcl-code-design.png)\\n\\nFig. 6: KCL core design.\\n\\nFor more language design and capabilities, see [KCL Documents](https://kcl-lang.io/docs/reference/lang/tour). Although KCL is not a general language, it has corresponding application scenarios. As shown in Fig. 6, developers can write **config**, **schema**, **function** and **rule** through KCL, where config is used to define data, schema is used to describe the model definition of data, rule is used to validate data, and schema and rule can also be combined to use models and constraints that fully describe data, In addition, we can also use the lambda pure function in KCL to organize data code, encapsulate common code, and call it directly when needed.\\n\\nFor use cases, KCL can perform structured K-V data validation complex configuration model definition and abstraction, strong constraint verification to avoid configuration errors, automation integration and engineering expansion. These features and use cases are described below.\\n\\n### 2.1 Validation of Structured Data\\n\\nAs shown in Fig 7, KCL supports format validation of JSON/YAML data. As a configuration language, KCL covers almost all features of OpenAPI in terms of validation. In KCL, the configuration data can be constrained by a structure definition. At the same time, it supports user-defined constraint rules through check blocks, and writing validation expressions in the schema to verify and constrain the attributes defined in the schema. The check expression can be used to clearly and simply verify whether the input JSON/YAML meets the corresponding schema structure definition and check constraints.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/07-kcl-validation.png)\\n\\nFig. 7: Validation of structured data in KCL.\\n\\nBased on this, KCL provides the corresponding [Validation Tool](https://kcl-lang.io/docs/tools/cli/kcl/vet) to validate JSON/YAML data directly. In addition, based on this capability, we can build a K-V validation visualization product as shown in Fig. 8.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/08-kcl-validation-ui.png)\\n\\nFig. 8: A K-V validation visualization product based on KCL.\\n\\n### 2.2 Definition and Abstraction of Complex Configuration Model\\n\\nAs shown in Fig 9, with the help of the [KCL OpenAPI](https://kcl-lang.io/docs/tools/cli/openapi/) tool, we can directly integrate a wide range of well-designed models.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/09-kcl-modeling.png)\\n\\nFig. 9: General way of KCL complex configuration modeling.\\n\\nAs shown in Figure 10, [Konfig](https://github.com/KusionStack/konfig) is used to manage all KCL configuration codes, the business configuration code and basic configuration code are stored in a mono repo, which facilitates the version dependency management between codes, and the automatic system processing is relatively simple. It is sufficient to locate the directory and files of the unique code base. The codes are interconnected, managed uniformly, and easy to find, modify, and maintain. Besides, the unified CI/CD process can be used for configuration management.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/10-kcl-konfig.png)\\n\\nFig. 10: Using KCL\'s language capabilities to integrate domain models and user models.\\n\\n### 2.3 Strong Constraint to Avoid Errors\\n\\nAs shown in Fig. 11, configuration errors can be avoided through strong constraint-checking methods in KCL.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/11-kcl-constraint.png)\\n\\nFig. 11: Strong constraint checking methods in KCL.\\n\\n- The KCL language\'s type system is designed to be static. Type and value definitions are separated. Type derivation and type checking at compile time are supported. Static types can not only analyze most type errors at compile time in advance, but also reduce the performance loss of dynamic type checking at runtime. In addition, the attributes of the KCL schema are forced to be not null, which can effectively avoid configuration omissions.\\n- When KCL configurations to be exported are declared, their types and values cannot change. This static feature ensures that the configuration will not be tampered with at will.\\n- KCL supports further ensuring stability through the built-in validation rules of the structure. For example, Fig. 12 shows that the KCL code defines the constraints for `containerPort`, `services`, and `volumes` in `App`.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/12-kcl-app-schema.png)\\n\\nFig. 12: KCL code validation with constraint rules.\\n\\n### 2.4 Isolated Configuration Block Merging\\n\\nKCL provides the ability to write isolated configuration blocks and automatically merge them, and supports idempotent merge, patch merge, and other strategies. Multiple configurations in idempotent merging need to meet the exchange law, and developers need to manually handle configuration conflicts between base and different environments. The patch merging includes overlay, deletion and addition. KCL simplifies the collaborative development on the user side and reduces the coupling between configurations through multiple merging strategies.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/13-kcl-isolated-config.png)\\n\\nFig. 13: Multi-environment scenario configuration block writing.\\n\\n### 2.5 Automation\\n\\nKCL provides many automation-related capabilities, mainly including tools and multilingual APIs. Via `package_identifier : key_identifier` mode, KCL supports the indexing of any configured key value, thus completing the addition, deletion, modification and query of any key value. For example, Fig 14. shows that we can directly execute the following command to modify the image. The code diff before and after modification is also shown in Fig. 14.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/14-kcl-image-update.png)\\n\\nFig. 14: Automatic modification of application configuration image via KCL CLI/API.\\n\\nIn addition, the automation capability of KCL can be realized and integrated into CI/CD as shown in Fig. 15.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/15-kcl-automation.png)\\n\\nFig. 15: Typical KCL automation integration.\\n\\n## 3. Comparison between KCL and Other Declarative Configurations\\n\\n### 3.1 vs. JSON/YAML\\n\\nYAML/JSON configurations are suitable for small-scale configuration scenarios. For large-scale cloud native configuration scenarios that need frequent modifications, they are more suitable for KCL. The main difference involved is the difference between configuration data abstraction and deployment:\\n\\nThe advantages of using KCL for configuration are: for static data, the advantage of abstracting one layer means that the overall system has **deployment flexibility**. Different configuration environments, tenants, and runtime may have different requirements for static data, and even different organizations may have different specifications and product requirements. KCL can be used to expose the most needed and frequently modified configurations to users.\\n\\n### 3.2 vs. Kustomize\\n\\nThe core capability of Kustomize is its file-level overlay capability. However, there is a problem with multiple overlay chains, because finding the statement of a specific attribute value does not guarantee that it is the final value, because another specific value that appears elsewhere can override it. For complex scenarios, retrieval of the inheritance chain of Kustomize files is often not as convenient as retrieval of the inheritance chain of KCL code, The specified configuration file overwrite order needs to be carefully considered. In addition, Kustomize cannot solve the problems of YAML configuration writing, constraint verification, model abstraction and development, and is more suitable for simple configuration scenarios.\\n\\nIn KCL, the configuration merge operation can be fine-grained to each configuration attribute in the code, and the merge strategy can be flexibly set, not limited to the overall resource, and the dependency between configurations can be statically analyzed through the import statement of KCL.\\n\\n### 3.3 vs. HCL\\n\\n#### 3.3.1 Features\\n\\n|  | HCL | KCL |\\n| --- | --- | --- |\\n| Modeling | The user interface is not directly perceived through the Terraform provider Schema definition. In addition, the user interface is cumbersome when writing complex object and required/optional field definitions. | Modeling through KCL schema, and achieve high model abstraction through language level engineering and some object-oriented features. |\\n| Constraint | The dynamic parameters are constrained by the condition field of the variable. The constraints of the resource itself need to be defined by provider schema or combined with Sentinel/Rego and other policy languages. The integrity of the language itself cannot be self closed, and its implementation methods are not unified | Define structures and constraints in a unified way. |\\n| Scalability | Terraform HCL overrides by file. The mode is fixed and the capability is limited. | KCL can customize the configuration block writing method and multiple strategies to meet the requirements of complex multi-tenant and multi-environment configuration scenarios. |\\n| Code writing | The user interface is complicated when writing complex object definitions and required/optional field definitions. | Complex structure definitions and constraint are easy to write without using other GPLs or tools. |\\n\\n#### 3.3.2 Examples\\n\\n**Terraform HCL variable vs. KCL schema**\\n\\n- HCL\\n\\n```python\\nvariable \\"subnet_delegations\\" {\\n  type = list(object({\\n    name               = string\\n    service_delegation = object({\\n      name    = string\\n      actions = list(string)\\n    })\\n  }))\\n  default     = null\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for d in var.subnet_delegations : (d != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for n in var.subnet_delegations.*.name : (n != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for d in var.subnet_delegations.*.service_delegation : (d != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for n in var.subnet_delegations.*.service_delegation.name : (n != null)])\\n  }\\n}\\n```\\n\\n- KCL\\n\\n```python\\nschema SubnetDelegation:\\n    name: str\\n    service_delegation: ServiceDelegation\\n\\nschema ServiceDelegation:\\n    name: str  # Required attributes\\n    actions?: [str]  # Optional attributes\\n\\nsubnet_delegations: [SubnetDelegation] = option(\\"subnet_delegations\\")\\n```\\n\\n**Terraform HCL Function vs. KCL Lambda**\\n\\n- As shown in [https://www.terraform.io/language/functions](https://www.terraform.io/language/functions) and [https://github.com/hashicorp/terraform/issues/27696](https://github.com/hashicorp/terraform/issues/27696)\uff0cTerraform HCL provides rich built-in functions, but it does not support users to define functions in Terraform (or need to write complex Go providers to simulate local user-defined functions); KCL not only supports users to use the lambda keyword to directly define functions in KCL code, but also supports the use of Python, Go and other languages to write [plugins](https://kcl-lang.io/docs/reference/plugin/overview).\\n\\n- Defining functions and calling them in KCL\\n\\n```python\\nadd_func = lambda x: int, y: int -> int {\\n    x + y\\n}\\ntwo = add_func(1, 1)  # 2\\n```\\n\\n**Remove null values in HCL vs. Remove null values in KCL**\\n\\n- HCL\\n\\n```python\\nvariable \\"conf\\" {\\n  type = object({\\n    description = string\\n    name        = string\\n    namespace   = string\\n    params = list(object({\\n      default     = optional(string)\\n      description = string\\n      name        = string\\n      type        = string\\n    }))\\n    resources = optional(object({\\n      inputs = optional(list(object({\\n        name = string\\n        type = string\\n      })))\\n      outputs = optional(list(object({\\n        name = string\\n        type = string\\n      })))\\n    }))\\n    results = optional(list(object({\\n      name        = string\\n      description = string\\n    })))\\n    steps = list(object({\\n      args    = optional(list(string))\\n      command = optional(list(string))\\n      env = optional(list(object({\\n        name  = string\\n        value = string\\n      })))\\n      image = string\\n      name  = string\\n      resources = optional(object({\\n        limits = optional(object({\\n          cpu    = string\\n          memory = string\\n        }))\\n        requests = optional(object({\\n          cpu    = string\\n          memory = string\\n        }))\\n      }))\\n      script     = optional(string)\\n      workingDir = string\\n    }))\\n  })\\n}\\n\\nlocals {\\n  conf = merge(\\n    defaults(var.conf, {}),\\n    { for k, v in var.conf : k => v if v != null },\\n    { resources = { for k, v in var.conf.resources : k => v if v != null } },\\n    { steps = [for step in var.conf.steps : merge(\\n      { resources = {} },\\n      { for k, v in step : k => v if v != null },\\n    )] },\\n  )\\n}\\n```\\n\\n- KCL (using `-n` flag)\\n\\n```python\\nschema Param:\\n    default?: str\\n    name: str\\n\\nschema Resource:\\n    cpu: str\\n    memory: str\\n\\nschema Step:\\n    args?: [str]\\n    command?: [str]\\n    env?: {str:str}\\n    image: str\\n    name: str\\n    resources?: {\\"limits\\" | \\"requests\\": Resource}\\n    script?: str\\n    workingDir: str\\n\\nschema K8sManifest:\\n    name: str\\n    namespace: str\\n    params: [Param]\\n    results?: [str]\\n    steps: [Step]\\n\\nconf: K8sManifest = option(\\"conf\\")\\n```\\n\\nTo sum up, in KCL, its types and constraints are defined in a declarative way through schema. It can be seen that compared with Terraform HCL, KCL constraints can be written more simply when the same functions are implemented (validation and condition fields do not need to be written repeatedly like Terraform), In addition, it provides the ability to set fields as optional (unlike the Terraform configuration field, which can be null by default).\\n\\n### 3.4 vs. CUE\\n\\n#### 3.4.1 Features\\n\\n|  | CUE | KCL |\\n| --- | --- | --- |\\n| Modeling | Modeling through struct, no inheritance and other features, can achieve high abstraction when there is no conflict between model definitions. Because CUE performs all constraint checks at runtime, there may be performance bottlenecks in large-scale modeling scenarios. | Modeling is conducted through KCL schema, and high model abstraction can be achieved through language level engineering and some object-oriented features (such as single inheritance). KCL is a statically compiled language with low overhead for large-scale modeling scenarios. |\\n| Constraint | CUE combines types and values into one concept. It simplifies the writing of constraints through various syntax. For example, generic types and enumerations are not required. Summing types and null value merging are the same thing. | KCL provides a richer check declarative constraint syntax, which makes it easier to write. For some configuration field combination constraints, it is simpler to write (compared with CUE, KCL provides more if guard combination constraints, all/any/map/filter and other collection constraint writing methods, which makes it easier to write) |\\n| Scalability | CUE supports configuration merging but it is completely idempotent. It may not meet the requirements of complex multi-tenant and multi- environment configuration scenarios | KCL can customize the configuration block writing method and multiple strategies to meet the requirements of complex multi-tenant and multi-environment configuration scenarios. |\\n| Code writing | For complex loop and constraint scenarios, it is complex to write, and it is cumbersome to write scenarios that require accurate configuration modifications. | Complex structure definition, loop, and conditional constraint scenarios are easy to write. |\\n\\n#### 3.4.2 Examples\\n\\n**CUE constraint vs. KCL constraint**\\n\\nCUE (run `cue export base.cue prod.cue`)\\n\\n- base.cue\\n\\n```cue\\n// base.cue\\nimport \\"list\\"\\n\\n#App: {\\n    domainType: \\"Standard\\" | \\"Customized\\" | \\"Global\\",\\n    containerPort: >=1 & <=65535,\\n    volumes: [...#Volume],\\n    services: [...#Service],\\n}\\n\\n#Service: {\\n    clusterIP: string,\\n    type: string,\\n\\n    if type == \\"ClusterIP\\" {\\n        clusterIP: \\"None\\"\\n    }\\n}\\n\\n#Volume: {\\n    container: string | *\\"*\\"  // The default value of `container` is \\"*\\"\\n    mountPath: string,\\n    _check: false & list.Contains([\\"/\\", \\"/boot\\", \\"/home\\", \\"dev\\", \\"/etc\\", \\"/root\\"], mountPath),\\n}\\n\\napp: #App & {\\n    domainType: \\"Standard\\",\\n    containerPort: 80,\\n    volumes: [\\n        {\\n            mountPath: \\"/tmp\\"\\n        }\\n    ],\\n    services: [\\n        {\\n            clusterIP: \\"None\\",\\n            type: \\"ClusterIP\\"\\n        }\\n    ]\\n}\\n\\n```\\n\\n- prod.cue\\n\\n```python\\n// prod.cue\\napp: #App & {\\n    containerPort: 8080,  // error: app.containerPort: conflicting values 8080 and 80:\\n}\\n```\\n\\nKCL (run `kcl base.k prod.k`)\\n\\n- base.k\\n\\n```python\\n# base.k\\nschema App:\\n    domainType: \\"Standard\\" | \\"Customized\\" | \\"Global\\"\\n    containerPort: int\\n    volumes: [Volume]\\n    services: [Service]\\n\\n    check:\\n        1 <= containerPort <= 65535\\n\\nschema Service:\\n    clusterIP: str\\n    $type: str\\n\\n    check:\\n        clusterIP == \\"None\\" if $type == \\"ClusterIP\\"\\n\\nschema Volume:\\n    container: str = \\"*\\"  # The default value of `container` is \\"*\\"\\n    mountPath: str\\n\\n    check:\\n        mountPath not in [\\"/\\", \\"/boot\\", \\"/home\\", \\"dev\\", \\"/etc\\", \\"/root\\"]\\n\\napp: App {\\n    domainType = \\"Standard\\"\\n    containerPort = 80\\n    volumes = [\\n        {\\n            mountPath = \\"/tmp\\"\\n        }\\n    ]\\n    services = [\\n        {\\n            clusterIP = \\"None\\"\\n            $type = \\"ClusterIP\\"\\n        }\\n    ]\\n}\\n\\n```\\n\\n- prod.k\\n\\n```python\\n# prod.k\\napp: App {\\n    # Using `=` attribute operator to modify the `containerPort` of the base `app`.\\n    containerPort = 8080\\n    # Using `+=` attribute operator to add volumes of the base `app`.\\n    # Here, it means to add one volume in the prod environment.\\n    volumes += [\\n        {\\n            mountPath = \\"/tmp2\\"\\n        }\\n    ]\\n}\\n```\\n\\nIn addition, due to the idempotent merge feature of CUE, it is not easy to use an overlay configuration similar to Kustomize to override the additional capability in scenarios, such as the above CUE code will report a conflict error.\\n\\n### 3.5 Performance\\n\\nKCL performs better than CUE/Jsonnet/HCL and other languages in scenarios with large code size or high computation load (CUE and other languages are limited by the runtime constraint checking overhead, while KCL is a statically compiled language).\\n\\n- CUE (test.cue)\\n\\n```cue\\nimport \\"list\\"\\n\\ntemp: {\\n        for i, _ in list.Range(0, 10000, 1) {\\n                \\"a\\\\(i)\\": list.Max([1, 2])\\n        }\\n}\\n```\\n\\n- KCL (test.k)\\n\\n```python\\na = lambda x: int, y: int -> int {\\n    max([x, y])\\n}\\ntemp = {\\"a${i}\\": a(1, 2) for i in range(10000)}\\n```\\n\\n- Jsonnet (test.jsonnet)\\n\\n```jsonnet\\nlocal a(x, y) = std.max(x, y);\\n{\\n    temp: {[\\"a%d\\" % i]: a(1, 2) for i in std.range(0, 10000)},\\n}\\n```\\n\\n- Terraform HCL (test.tf. Since the terraform `range` function only supports up to 1024 iterators, the `range(10000)` is divided into 10 sub ranges)\\n\\n```python\\noutput \\"r1\\" {\\n  value = {for s in range(0, 1000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r2\\" {\\n  value = {for s in range(1000, 2000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r3\\" {\\n  value = {for s in range(1000, 2000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r4\\" {\\n  value = {for s in range(2000, 3000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r5\\" {\\n  value = {for s in range(3000, 4000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r6\\" {\\n  value = {for s in range(5000, 6000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r7\\" {\\n  value = {for s in range(6000, 7000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r8\\" {\\n  value = {for s in range(7000, 8000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r9\\" {\\n  value = {for s in range(8000, 9000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r10\\" {\\n  value = {for s in range(9000, 10000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\n```\\n\\n- Running time (considering the actual resource cost of the production environment, this test is subject to the single core).\\n\\n| Environment | KCL v0.4.3 Running time (including compilation+runtime) | CUE v0.4.3 Running time (including compilation+runtime) | Jsonnet v0.18.0 Running time (including compilation+runtime)  | HCL in Terraform v1.3.0 Running time (including compilation+runtime) |\\n| --- | --- | --- | --- | --- |\\n| OS: macOS 10.15.7; CPU: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz; Memory: 32 GB 2400 MHz DDR4; no NUMA | 440 ms (kclvm_cli run test.k) | 6290 ms (cue export test.cue) | 3340 ms (jsonnet test.jsonnet) | 1774 ms (terraform plan -parallelism=1) |\\n\\n#### Another Complex Case\\n\\nUsing KCL and CUE to write Kubernetes configuration.\\n\\n- CUE (test.cue)\\n\\n```cue\\npackage templates\\n\\nimport (\\n apps \\"k8s.io/api/apps/v1\\"\\n)\\n\\ndeployment: apps.#Deployment\\n\\ndeployment: {\\n apiVersion: \\"apps/v1\\"\\n kind:       \\"Deployment\\"\\n metadata: {\\n  name:   \\"me\\"\\n  labels: me: \\"me\\"\\n }\\n}\\n```\\n\\n- KCL (test.k)\\n\\n```python\\nimport kubernetes.api.apps.v1\\n\\ndeployment = v1.Deployment {\\n    metadata.name = \\"me\\"\\n    metadata.labels.name = \\"me\\"\\n}\\n```\\n\\n| Environment | KCL v0.4.3 Running time (including compilation+runtime) | CUE v0.4.3 Running time (including compilation+runtime) |\\n| --- | --- | --- |\\n| OS: macOS 10.15.7; CPU: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz; Memory: 32 GB 2400 MHz DDR4; no NUMA | 140 ms (kclvm_cli run test.k) | 350 ms (cue export test.cue) |\\n\\n## 4. Summary\\n\\nThe blog gives a landscape overview of declarative configuration technology, focusing on the KCL concept, core features, usage cases and comparison with other configuration languages, hoping to help you understand declarative configuration technology and KCL language. For more information about the concept, background and design of KCL, please visit the [KCL website](https://kcl-lang.io/)\\n\\n## 5. Reference\\n\\n- KusionStack Cloud Native Configuration Practice Blog: [https://kusionstack.io/blog/2021-kusion-intro](https://kusionstack.io/blog/2021-kusion-intro)\\n- Terraform Language: [https://www.terraform.io/language](https://www.terraform.io/language)\\n- Terraform Provider Kubernetes: [https://github.com/hashicorp/terraform-provider-kubernetes](https://github.com/hashicorp/terraform-provider-kubernetes)\\n- Terraform Provider AWS: [https://github.com/hashicorp/terraform-provider-aws](https://github.com/hashicorp/terraform-provider-aws)\\n- Pulumi: [https://www.pulumi.com/docs/](https://www.pulumi.com/docs/)\\n- Pulumi vs. Terraform: [https://www.pulumi.com/docs/intro/vs/terraform/](https://www.pulumi.com/docs/intro/vs/terraform/)\\n- Google SRE Work Book Configuration Design: [https://sre.google/workbook/configuration-design/](https://sre.google/workbook/configuration-design/)\\n- Google Borg Paper: [https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf)\\n- Holistic Configuration Management at Facebook: [https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf](https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf)\\n- JSON Spec: [https://www.json.org/json-en.html](https://www.json.org/json-en.html)\\n- YAML Spec: [https://yaml.org/spec/](https://yaml.org/spec/)\\n- GCL: [https://github.com/rix0rrr/gcl](https://github.com/rix0rrr/gcl)\\n- HCL: [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)\\n- CUE: [https://github.com/cue-lang/cue](https://github.com/cue-lang/cue)\\n- Jsonnet: [https://github.com/google/jsonnet](https://github.com/google/jsonnet)\\n- Dhall: [https://github.com/dhall-lang/dhall-lang](https://github.com/dhall-lang/dhall-lang)\\n- Thrift: [https://github.com/Thriftpy/thriftpy2](https://github.com/Thriftpy/thriftpy2)\\n- Kustomize: [https://kustomize.io/](https://kustomize.io/)\\n- Kube-linter: [https://github.com/stackrox/kube-linter](https://github.com/stackrox/kube-linter)\\n- Checkov: [https://github.com/bridgecrewio/checkov](https://github.com/bridgecrewio/checkov)\\n- KCL Documents: [https://kcl-lang.io/docs/reference/lang/tour](https://kcl-lang.io/docs/reference/lang/tour)\\n- How Terraform Works: A Visual Intro: [https://betterprogramming.pub/how-terraform-works-a-visual-intro-6328cddbe067](https://betterprogramming.pub/how-terraform-works-a-visual-intro-6328cddbe067) \\n- How Terraform Works: Modules Illustrated: [https://awstip.com/terraform-modules-illustrate-26cbc48be83a](https://awstip.com/terraform-modules-illustrate-26cbc48be83a)\\n- Helm: [https://helm.sh/](https://helm.sh/)\\n- Helm vs. Kustomize: [https://harness.io/blog/helm-vs-kustomize](https://harness.io/blog/helm-vs-kustomize)\\n- KubeVela: [https://kubevela.io/docs/](https://kubevela.io/docs/)"},{"id":"2021-kcl-intro","metadata":{"permalink":"/blog/2021-kcl-intro","editUrl":"https://github.com/KusionStack/kcl-lang.io/tree/main/blog/2021-08-03-kcl-giac-metting/index.md","source":"@site/blog/2021-08-03-kcl-giac-metting/index.md","title":"KCL Introduction on GIAC 2021 Meeting","description":"This blog introduces the birth background, language characteristics, practical exploration and future development of KCL.","date":"2021-08-03T00:00:00.000Z","formattedDate":"August 3, 2021","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":0.125,"hasTruncateMarker":false,"authors":[{"name":"Shushan, Chai","title":"KCL Team Member"}],"frontMatter":{"slug":"2021-kcl-intro","title":"KCL Introduction on GIAC 2021 Meeting","authors":{"name":"Shushan, Chai","title":"KCL Team Member"},"tags":["KCL"]},"prevItem":{"title":"The Landscape of Declarative Configuration","permalink":"/blog/2022-declarative-config-overview"}},"content":"This blog introduces the birth background, language characteristics, practical exploration and future development of KCL.\\n\\n- Introduction\uff1ahttps://giac.msup.com.cn/course?id=15307\\n- Content\uff1ahttps://segmentfault.com/a/1190000040455559\\n- [PDF (Chinese)](https://gw.alipayobjects.com/os/bmw-prod/2cb0c283-5f24-485e-b635-b6efac887eba.pdf)\\n\\n[![KCL Talk Cover](/img/blog/2021-08-03-kcl-intro/talk-cover.png)](https://gw.alipayobjects.com/os/bmw-prod/2cb0c283-5f24-485e-b635-b6efac887eba.pdf)"}]}')}}]);