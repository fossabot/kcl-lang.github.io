"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"2022-kcl-osdt-meeting","metadata":{"permalink":"/blog/2022-kcl-osdt-meeting","editUrl":"https://github.com/KusionStack/kcl-lang.io/blob/main/blog/2022-12-10-kcl-osdt-meeting/index.md","source":"@site/blog/2022-12-10-kcl-osdt-meeting/index.md","title":"KCL Introduction on OSDT 2022 Meeting","description":"Download PDF","date":"2022-12-10T00:00:00.000Z","formattedDate":"December 10, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"},{"label":"Policy","permalink":"/blog/tags/policy"}],"readingTime":0.01,"truncated":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-osdt-meeting","title":"KCL Introduction on OSDT 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration","Policy"]},"nextItem":{"title":"KCL v0.4.4 Release Blog","permalink":"/blog/2022-kcl-0.4.4-release-blog"}},"content":"[Download PDF](https://kcl-lang.github.io/talks/kcl-osdt2022.pdf)"},{"id":"2022-kcl-0.4.4-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.4-release-blog","editUrl":"https://github.com/KusionStack/kcl-lang.io/blob/main/blog/2022-12-06-kcl-0.4.4-release-blog/index.md","source":"@site/blog/2022-12-06-kcl-0.4.4-release-blog/index.md","title":"KCL v0.4.4 Release Blog","description":"The KCL team is pleased to announce that v0.4.4 is now available! This release mainly adds the ability to customize YAML manifests output for KCL. Users can customize the style of YAML output by writing code and calling system functions without understanding the complex schema settings semantics. In addition, this release provides the latest KCL Python SDK, which can be used for Python users to directly integrate KCL. At the same time, we have greatly reduced the size of the KCL installation package. The average installation package size has been reduced to one-fifth of that of the previous version. It also includes a number of compiler error message optimization and bug fix. You can visit the KCL release page to get more detailed release information and KCL binary download link.","date":"2022-12-06T00:00:00.000Z","formattedDate":"December 6, 2022","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"KusionStack","permalink":"/blog/tags/kusion-stack"},{"label":"Kusion","permalink":"/blog/tags/kusion"}],"readingTime":6.32,"truncated":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.4-release-blog","title":"KCL v0.4.4 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL","KusionStack","Kusion"]},"prevItem":{"title":"KCL Introduction on OSDT 2022 Meeting","permalink":"/blog/2022-kcl-osdt-meeting"},"nextItem":{"title":"40x Faster! We rewrote our project with Rust","permalink":"/blog/2022-kcl-rewrite-with-rust"}},"content":"The KCL team is pleased to announce that v0.4.4 is now available! This release mainly adds the ability to customize YAML manifests output for KCL. Users can customize the style of YAML output by writing code and calling system functions without understanding the complex schema settings semantics. In addition, this release provides the latest [KCL Python SDK](https://github.com/KusionStack/kclvm-py), which can be used for Python users to directly integrate KCL. At the same time, we have greatly reduced the size of the KCL installation package. The average installation package size has been reduced to one-fifth of that of the previous version. It also includes a number of compiler error message optimization and bug fix. You can visit the [KCL release page](https://github.com/KusionStack/KCLVM/releases/tag/v0.4.4-alpha.2) to get more detailed release information and KCL binary download link.\\n\\n## Background\\n\\nKCL is an open-source constraint-based record and functional language. KCL improves the writing of a large number of complex configurations through mature programming language technology and practice, and is committed to building better modularity, scalability and stability around configuration, simpler logic writing, fast automation and good ecological extensionality.\\n\\nThis blog will introduce the recent developments of KCL community to readers.\\n\\n## Features\\n\\n### Customize YAML Manifest Output\\n\\nIn previous KCL versions, the style of YAML output is hard coded in the KCL compiler, and users can set the `__settings__` meta attribute with different values to determine the YAML output style, which brings high complexity. Therefore, in version 0.4.4, we provide a system module function for developers to easily customize the YAML output style. The signature of this function is as follows:\\n\\n```python\\nmanifests.yaml_stream(values: [any], opts: {str:} = {\\n    sort_keys = False\\n    ignore_private = True\\n    ignore_none = False\\n    sep = \\"---\\"\\n})\\n```\\n\\nThis function is used to serialize the KCL object list into YAML output with the `---` separator. It has two parameters:\\n\\n+ `values` - A list of KCL objects\\n+ `opts` - The YAML serialization options\\n  + `sort_keys`: Whether to sort the serialized results in the dictionary order of attribute names (the default is `False`).\\n  + `ignore_private`: Whether to ignore the attribute output whose name starts with the character `_` (the default value is `True`).\\n  + `ignore_none`: Whether to ignore the attribute with the value of\' None \'(the default value is `False`).\\n  + `sep`: Set the separator between multiple YAML documents (the default value is `\\"---\\"`).\\n\\nHere\'s an example:\\n\\n```python\\nimport manifests\\n\\nschema Deployment:\\n    apiVersion: str = \\"v1\\"\\n    kind: str = \\"Deployment\\"\\n    metadata: {str:} = {\\n        name = \\"deploy\\"\\n    }\\n    spec: {str:} = {\\n        replica = 2\\n    }\\n\\nschema Service:\\n    apiVersion: str = \\"v1\\"\\n    kind: str = \\"Service\\"\\n    metadata: {str:} = {\\n         name = \\"svc\\"\\n    }\\n    spec: {str:} = {}    \\n        \\ndeployments = [Deployment {}, Deployment {}]\\nservices = [Service {}, Service {}]\\n\\nmanifests.yaml_stream(deployments + services)\\n```\\n\\nFirst, we use the `import` keyword to import the `manifests` module and define two deployment resources and two service resources. When we want to output these four resources in YAML stream format with `---` as the separator, we can put them into a KCL list and use the `manifests.yaml_stream` function pass it to the `values` parameter (if there is no special requirement, the `opts` parameter can generally use the default value). Finally, the YAML output is:\\n\\n```yaml\\napiVersion: v1\\nkind: Deployment\\nmetadata:\\n  name: deploy\\nspec:\\n  replica: 2\\n---\\napiVersion: v1\\nkind: Deployment\\nmetadata:\\n  name: deploy\\nspec:\\n  replica: 2\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: svc\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: svc\\n```\\n\\n> Note: The feature of schema `__settings__` meta attribute setting YAML output style can still be used in v0.4.4. We will remove this feature in KCL v0.4.6 after the next two minor versions are released.\\n\\nFor more information, see [https://github.com/KusionStack/KCLVM/issues/94](https://github.com/KusionStack/KCLVM/issues/94).\\n\\n### Python SDK\\n\\nIn addition to the existing [KCL Go SDK](https://github.com/KusionStack/kclvm-go), this release also adds the KCL Python SDK. Using the Python SDK requires that you have a local Python version higher than 3.7.3 and a local pip package management tool. You can use the following command to install and obtain helpful information.\\n\\n```cmd\\n$ python3 -m pip install kclvm && python3 -m kclvm --help\\n```\\n\\n#### Command Line Tool\\n\\nPrepare a KCL file named `main.k`\\n\\n```python\\nname = \\"kcl\\"\\nage = 1\\n\\nschema Person:\\n    name: str = \\"kcl\\"\\n    age: int = 1\\n\\nx0 = Person {}\\nx1 = Person {\\n    age = 101\\n}\\n```\\n\\nExecute the following command and get the output:\\n\\n```cmd\\n$ python3 -m kclvm hello.k\\nname: kcl\\nage: 1\\nx0:\\n  name: kcl\\n  age: 1\\nx1:\\n  name: kcl\\n  age: 101\\n```\\n\\n#### API\\n\\nIn addition, we can also execute KCL files through Python code.\\n\\nPrepare a KCL file named `main.py`\\n\\n```python\\nimport kclvm.program.exec as kclvm_exec\\nimport kclvm.vm.planner as planner\\n\\nprint(planner.plan(kclvm_exec.Run([\\"hello.k\\"]).filter_by_path_selector()))\\n```\\n\\nExecute the following command and get the output:\\n\\n```cmd\\n$ python3 main.py\\nname: kcl\\nage: 1\\nx0:\\n  name: kcl\\n  age: 1\\nx1:\\n  name: kcl\\n  age: 101\\n```\\n\\nYou can see that the same output can be obtained through command line tools and APIs.\\n\\nAt present, the KCL Python SDK is still in the early preview version. The KCL team will continue to update and provide more functions in the future. For more information, see [https://github.com/KusionStack/kclvm-py](https://github.com/KusionStack/kclvm-py)\\n\\n## Installation Size Optimization\\n\\nIn the new KCL version, we split the built-in Python 3 of KCL, reducing the average size of the KCL binary compression package from 200M to 35M. Users can download and use KCL faster, and the Python plugin becomes an option. If you want to enable the KCL Python plugin, an additional requirement is that you have Python and pip package management tools that are higher than 3.7.3. For more details, please see [https://github.com/KusionStack/kcl-plugin](https://github.com/KusionStack/kcl-plugin)\\n\\n## Bugfix\\n\\n### Function Call Error Information Optimization\\n\\nIn version 0.4.4, KCL optimizes the output of error messages when the number of function arguments does not match, and supports the display of function names and the number of argument mismatches\\n\\n```python\\nschema Foo[x: int]:\\n    bar?: int = x\\n\\nf = lambda x {\\n    x + 1\\n}\\n\\nfoo = Foo(1,2,3)  # Error: \\"Foo\\" takes 1 positional argument but 3 were given\\nf(1,2)  # Error: \\"f\\" takes 1 positional argument but 2 were given\\n```\\n\\nFor more information, see [https://github.com/KusionStack/KCLVM/issues/299](https://github.com/KusionStack/KCLVM/issues/299)\\n\\n### Formatting Error of Interpolated Three Quote String\\n\\nIn previous KCL versions, formatting the following code would incorrectly convert the three quotation marks with string interpolation into single quotation marks and cause compilation errors. In version 0.4.4, we fixed the issue.\\n\\n```python\\n# Before KCL v0.4.4, variable \\"bar\\" will be formatted as:\\n#\\n# foo = 1\\n# bar = \\"\\n# ${foo}\\n# \\"\\nfoo = 1\\nbar = \\"\\"\\"\\n${foo}\\n\\"\\"\\"\\n```\\n\\nFor more information, see [https://github.com/KusionStack/KCLVM/issues/294](https://github.com/KusionStack/KCLVM/issues/294)\\n\\n### Other Issues\\n\\nFor more issues, see [https://github.com/KusionStack/KCLVM/milestone/2?closed=1](https://github.com/KusionStack/KCLVM/milestone/2?closed=1)\\n\\n## Documents\\n\\n[KCL website](https://kcl-lang.github.io/) preliminary establishment and improvement of Kubernetes scenarios [related documents](https://kcl-lang.github.io/docs/user_docs/guides/working-with-k8s/).\\n\\nFor more information, see [https://kcl-lang.github.io/](https://kcl-lang.github.io/)\\n\\n## Community\\n\\nThree external contributors @my-vegetable-has-exploded, @possible-fqz, @orangebees have participated in the KCL community, thank them for their enthusiasm and active participation in contributing.\\n\\n## Next\\n\\nIt is estimated that by the end of January 2023, we will release KCL v0.4.5, and the key evolution is expected to include\\n\\n+ Continuous optimization of the KCL user interface, improvement of experience and user pain points.\\n+ More scenarios and ecology integration, such as Kubernetes and CI/CD Pipeline scenarios.\\n+ KCL Windows version support.\\n+ KCL package management tool `kpm` release.\\n+ The new version of KCL playground.\\n\\nFor more information, see [KCL v0.4.5 Milestone](https://github.com/KusionStack/KCLVM/milestone/3).\\n\\n## FAQ\\n\\nFor more information, see [https://kcl-lang.github.io/docs/user_docs/support/](https://kcl-lang.github.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\n+ [KCL Website](https://kcl-lang.github.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/KusionStack/KCLVM)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/KusionStack/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-rewrite-with-rust","metadata":{"permalink":"/blog/2022-kcl-rewrite-with-rust","editUrl":"https://github.com/KusionStack/kcl-lang.io/blob/main/blog/2022-11-29-kcl-rewrite-with-rust/index.md","source":"@site/blog/2022-11-29-kcl-rewrite-with-rust/index.md","title":"40x Faster! We rewrote our project with Rust","description":"Introduction","date":"2022-11-29T00:00:00.000Z","formattedDate":"November 29, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Rust","permalink":"/blog/tags/rust"},{"label":"Performance","permalink":"/blog/tags/performance"},{"label":"Programming Language","permalink":"/blog/tags/programming-language"},{"label":"Compiler","permalink":"/blog/tags/compiler"}],"readingTime":9.74,"truncated":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-rewrite-with-rust","title":"40x Faster! We rewrote our project with Rust","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Rust","Performance","Programming Language","Compiler"]},"prevItem":{"title":"KCL v0.4.4 Release Blog","permalink":"/blog/2022-kcl-0.4.4-release-blog"},"nextItem":{"title":"KCL Introduction on SETTA 2022 Meeting","permalink":"/blog/2022-kcl-setta-meeting"}},"content":"## Introduction\\n\\nRust has quietly become one of the most popular programming languages. As an emerging system language, Rust has many characteristics, such as the memory security mechanism, performance advantages close to C/C++, excellent developer community, experience of documents, tool chains and IDEs. This blog will introduce the process of using Rust to rewrite the project and gradually implementing the production environment, as well as the reasons for choosing Rust in the rewrite process, the problems encountered, and the results of using Rust to rewrite.\\n\\nThe project we are using Rust to develop is called [KCL](https://github.com/KusionStack/KCLVM). (KCL) is an open source constraint-based record and functional language. KCL improves the writing of a large number of complex configurations through mature programming language technology and practice, and is committed to building better modularity, scalability and stability around configuration, simpler logic writing, fast automation and good ecological extensionality. For more specific KCL usage scenarios, please visit the [KCL website](https://kcl-lang.github.io/). This blog will not repeat them too much.\\n\\nKCL was written in Python before. Considering the user experience, performance and stability, we have decided to rewrite it in Rust, and the following benefits were obtained:\\n\\n+ Fewer bugs due to Rust\'s powerful compilation check and error handling.\\n+ 66% improvement in language end-to-end compilation and execution performance.\\n+ The performance of the language front-end parser has been improved by 20 times.\\n+ The performance of the language semantic analyzer has been improved by 40 times.\\n+ The average memory usage of the language compiler during compilation is half of the original Python version.\\n\\n## What problems have we encountered\\n\\nThe compiler, build system or runtime uses Rust to do similar things in technology like projects of the same type in the community [deno](https://github.com/denoland/deno), [swc](https://github.com/swc-project/swc), [turbopack](https://github.com/vercel/turbo), [rustc](https://github.com/rust-lang/rust). We used Rust to completely build the front, middle and runtime of the compiler, and achieved some results, but we did not do this about a year ago.\\n\\nA year ago, we used Python to build the whole implementation of KCL compiler. Although it ran well at the beginning, Python was easy to use, rich in ecology, and the team\'s research and development efficiency was also very high, with the expansion of the code and the increase of the number of engineers, code maintenance became more difficult.\\n\\nAlthough we forced to write Python type annotations in the project and adopted stricter lint tools. Besides, the coverage of code test lines has also reached more than 90%, but there are still many runtime errors, such as Python None empty objects, attributes not found, and so on. We need to be careful when refactoring Python code, which seriously affects the user experience.\\n\\nIn addition, when KCL users are the majority of developers, any errors in the programming language or compiler internal implementation are intolerable, which also brings a series of problems to our user experience. Programs written in Python start slowly, and their performance cannot meet the efficiency demands of online compilation and execution of the automation system, because in our scenario, After users modify KCL code, they need to be able to quickly display the compilation results. Obviously, the compiler written in Python cannot meet the use requirements well.\\n\\n## Why use Rust\\n\\nWe chose Rust for the following reasons:\\n\\n+ We used Python, Go and Rust to implement a simple programming language stack virtual machine and made a performance comparison. In this scenario, Go and Rust have similar performance, Python has a large performance gap, and Rust is adopted under comprehensive consideration. The details of the stack virtual machine code implemented by the three languages are here: [https://github.com/Peefy/StackMachine](https://github.com/Peefy/StackMachine).\\n+ More and more compilers or runtimes of programming languages, especially front-end infrastructure projects, are written or refactored using Rust. In addition, Rust has appeared in infrastructure, database, search engine, network, cloud native, UI, embedded and other fields. At least, the feasibility and stability of the implementation of programming languages have been verified.\\n+ Considering that the subsequent project development will involve the direction of blockchain and smart contract, and a large number of blockchain and smart contract projects in the community are written by Rust.\\n+ Better performance and stability can be achieved through Rust, making the system easier to maintain and more robust. At the same time, C APIs can be exposed through FFI for multilingual use and expansion, facilitating ecological expansion and integration.\\n+ Rust supports WASM in a friendly way. A large number of WASM ecosystems in the community are built by Rust. KCL languages and compilers can be compiled into WASM with the help of Rust and run in browsers.\\n\\nBased on the above reasons, we chose Rust instead of Go. In the whole rewriting process, we found that Rust\'s comprehensive quality is really excellent (high performance and enough abstraction). Although there is some cost in some language features, especially the lifetime, it is not rich in ecology.\\n\\n## What are the difficulties in using Rust\\n\\nAlthough we decided to rewrite the entire KCL project with Rust, most team members have no experience in writing a certain project with Rust, and I has only learned [The Rust Programming Language](https://doc.rust-lang.org/book/). I vaguely remember that I gave up when I learned about intelligent pointers such as `Rc` and `RefCell`. At that time, I didn\'t expect that there would be anything similar to C++ in Rust.\\n\\nThe risk of using Rust is mainly the cost of Rust language learning, which is indeed mentioned in various Rust blogs. Because the overall architecture of the KCL project has not changed much, and some module design and code writing have been optimized for Rust, so the entire rewrite is carried out in the process of learning while practicing. When we first started to use Rust to write the whole project, we still spent a lot of time on knowledge query, compilation and debugging. However, as the project progressed, the difficulties we encountered in our experience when using Rust were mainly mental transformation and development efficiency.\\n\\n### Mental transformation\\n\\nFirst of all, the syntax and semantics of Rust well absorb and integrate the concepts related to the type system in functional programming, such as the Abstract Algebraic Type (ADT). In addition, there is no concept related to \\"inheritance\\" in Rust. If you can\'t understand it well, even ordinary structure definitions in other languages may take a lot of time in Rust. For example, the following Python code may be defined like this in Rust\\n\\n+ Python\\n\\n```python\\nfrom dataclasses import dataclass\\n\\nclass KCLObject:\\n    pass\\n\\n@dataclass\\nclass KCLIntObject(KCLObject):\\n    value: int\\n\\n@dataclass\\nclass KCLFloatObject(KCLObject):\\n    value: float\\n```\\n\\n+ Rust\\n\\n```rust\\nenum KCLObject {\\n    Int(u64),\\n    Float(f64),\\n}\\n```\\n\\nOf course, more time is spent fighting against the error reports of the Rust compiler itself. The Rust compiler will often cause developers to \\"run into a wall\\", such as borrowing check errors. Especially for the KCL compiler, its core structure is the Abstract Syntax Tree (AST), which is a recursive and nested tree structure.\\n\\nIt is sometimes difficult to give consideration to the relationship between variable variability and borrowing check in Rust, Just like the scope structure `Scope` defined in KCL compiler, for scenarios with circular references, it is used to display the interdependence of data that needs to be aware of, while making extensive use of intelligent pointer structures commonly used in Rust such as `Rc`, `RefCell` and `Weak`.\\n\\n```rust\\n/// A Scope maintains a set of objects and links to its containing\\n/// (parent) and contained (children) scopes. Objects may be inserted\\n/// and looked up by name. The zero value for Scope is a ready-to-use\\n/// empty scope.\\n#[derive(Clone, Debug)]\\npub struct Scope {\\n    /// The parent scope.\\n    pub parent: Option<Weak<RefCell<Scope>>>,\\n    /// The child scope list.\\n    pub children: Vec<Rc<RefCell<Scope>>>,\\n    /// The scope object mapping with its name.\\n    pub elems: IndexMap<String, Rc<RefCell<ScopeObject>>>,\\n    /// The scope start position.\\n    pub start: Position,\\n    /// The scope end position.\\n    pub end: Position,\\n    /// The scope kind.\\n    pub kind: ScopeKind,\\n}\\n```\\n\\n### Development efficiency\\n\\nThe development efficiency of Rust can be described as \\"restraining first and then improving\\". At the beginning of the handwritten project, if the team members have not been exposed to the concept of functional programming and related programming habits, the development speed will be significantly slower than Python, Go, Java and other languages. However, once they become familiar with the common methods and best practices of the Rust standard library, as well as the common error modification of the Rust compiler, the development efficiency will be greatly improved, and they can write high-quality, safe and efficient code natively.\\n\\nFor example, I have encountered a Rust lifetime error as shown in the following code. After a long time of troubleshooting, it was found that the lifetime mismatch was caused by forgetting to label lifetime parameters. In addition, the lifetime of Rust is coupled with concepts such as type system, scope, ownership, and borrowing check, resulting in a high cost and complexity of understanding, and error reporting information is often not as obvious as type errors. The lifetime mismatch error reporting information is sometimes slightly inflexible, which may lead to a high cost of troubleshooting. Of course, the efficiency will be improved after more familiar with relevant concepts.\\n\\n```rust\\nstruct Data<\'a> {\\n    b: &\'a u8,\\n}\\n\\n// func2 omit lifecycle parameters, and func2 does not.\\n// The lifecycle of func2 will be deduced as \'_ by the Rust compiler by default,\\n// which may lead to lifetime mismatch error.\\nimpl<\'a> Data<\'a> {\\n    fn func1(&self) -> Data<\'a> {Data { b: &0 }}\\n    fn func2(&self) -> Data {Data { b: &0 }}\\n}\\n```\\n\\n## Rewrite revenue ratio using Rust\\n\\nAfter several members of the team spent several months using Rust to completely rewrite and stably put it into the production environment for several months, we reviewed the whole process and felt that it was very rewarding.\\n\\nFrom a technical perspective, the rewrite process not only trained to quickly learn a new programming language and programming knowledge, but also put them into practice, And the whole rewrite process made us reflect on the unreasonable design of the KCL compiler and modify it. For a programming language, this is a long cycle project. What we learned is that the compiler system is more stable, safe, with clear code, fewer bugs, and better performance.\\n\\nAlthough not all modules get 40 times the performance (because the performance bottleneck of some modules, such as the KCL runtime, is the memory deep copy operation), but I personally think it is still worthwhile. And when Rust has been used for a certain period of time, mind and development efficiency are no longer limiting factors.\\n\\n## Conclusion\\n\\nI personally think that the most important thing after using Rust to rewrite the project is whether I have learned a new programming language or whether Rust is very popular and we have written many fancy codes using Rust. It really makes the KCL language and compiler more stable, and the startup speed and automation efficiency are no longer troubled. The performance of KCL is better than that of other programming languages in the same type of fields in the community, so that users of our language and tools can experience the improvement. These are all due to Rust\'s no-GC, high-performance, better error handling, memory management, zero abstraction and other features. In short, as users, they are the biggest beneficiaries.\\n\\nFinally, if you like the KCL project, or want to use KCL for your own scenarios, or want to use Rust to participate in an open source project, welcome to visit [https://github.com/KusionStack/community](https://github.com/KusionStack/community) to join our community to participate in discussion and co construction \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f\u3002\\n\\n## Reference\\n\\n+ https://github.com/KusionStack/KCLVM\\n+ https://github.com/Peefy/StackMachine\\n+ https://doc.rust-lang.org/book/\\n+ https://github.com/sunface/rust-course\\n+ https://www.influxdata.com/blog/rust-can-be-difficult-to-learn-and-frustrating-but-its-also-the-most-exciting-thing-in-software-development-in-a-long-time/"},{"id":"2022-kcl-setta-meeting","metadata":{"permalink":"/blog/2022-kcl-setta-meeting","editUrl":"https://github.com/KusionStack/kcl-lang.io/blob/main/blog/2022-10-27-kcl-setta-meeting/index.md","source":"@site/blog/2022-10-27-kcl-setta-meeting/index.md","title":"KCL Introduction on SETTA 2022 Meeting","description":"Download PDF","date":"2022-10-27T00:00:00.000Z","formattedDate":"October 27, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":0.01,"truncated":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-setta-meeting","title":"KCL Introduction on SETTA 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"40x Faster! We rewrote our project with Rust","permalink":"/blog/2022-kcl-rewrite-with-rust"},"nextItem":{"title":"The Landscape of Declarative Configuration","permalink":"/blog/2022-declarative-config-overview"}},"content":"[Download PDF](https://kcl-lang.github.io/talks/kcl-setta2022.pdf)"},{"id":"2022-declarative-config-overview","metadata":{"permalink":"/blog/2022-declarative-config-overview","editUrl":"https://github.com/KusionStack/kcl-lang.io/blob/main/blog/2022-09-15-declarative-config-overview/index.md","source":"@site/blog/2022-09-15-declarative-config-overview/index.md","title":"The Landscape of Declarative Configuration","description":"The blog is only used to clarify the landscape of declarative configuration, KCL core concept and features, as well as the comparison with other configuration languages.","date":"2022-09-15T00:00:00.000Z","formattedDate":"September 15, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":26.71,"truncated":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-declarative-config-overview","title":"The Landscape of Declarative Configuration","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"KCL Introduction on SETTA 2022 Meeting","permalink":"/blog/2022-kcl-setta-meeting"},"nextItem":{"title":"KCL - Cloud Native Configuration and Policy Language","permalink":"/blog/2021-kcl-intro"}},"content":"The blog is only used to clarify the landscape of declarative configuration, [KCL](https://github.com/KusionStack/KCLVM) core concept and features, as well as the comparison with other configuration languages.\\n\\n## 1. The Landscape of Declarative Configuration\\n\\n### 1.1 Importance of Configuration\\n\\n- There are thousands of configuration updates every day because the software development and the configuration itself is gradually evolving, which has a high demand for large-scale efficiency.\\n  - **The configuration is updated more frequently**: The evolving business requirements, infrastructure requirements and other factors mean that the system needs to change constantly, and the configuration provides a low-cost way to change the system functions.\\n  - **The configuration scale is getting larger**: A configuration is often distributed to different cloud sites, different tenants, different environments, etc.\\n  - **Wide configuration scenarios**: Application, database, network, monitoring, etc.\\n  - **Various configuration formats**: JSON, YAML, XML, TOML, various configuration templates such as Java Velocity, Go Template, etc.\\n- The stability of the configuration is crucial. One of the main reasons for system errors is that a large number of engineers frequently update the configuration. Table 1 shows several system error events caused by configuration.\\n\\n| Time | Event |\\n| --- | --- |\\n| 2021.07 | The Bilibili website in China went down because SLB Lua configuration code fell into an infinite loop with calculation errors |\\n| 2021.10 | KT Company in South Korea suffers major network interruption nationwide due to wrong routing configuration |\\n\\nTable 1 System error events caused by configuration.\\n\\n### 1.2 Classification of Declarative Configuration\\n\\nThe cloud-native era has brought about rapid technological development, with a large number of declarative configurations. As shown in Fig. 1, declarative configuration can be generally divided into the following ways.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/01-declarative-config.png)\\n\\nFig. 1: Classification of declarative configuration.\\n\\n#### 1.2.1 Structured K-V\\n\\nStructured K-V meets the minimum data declaration requirements (int, string, list, dict, etc.). Declarative API meets the development demands of X as Data with the rapid development and application of cloud native technology. Machine-readable and writable, human-readable.\\n\\n- Pros.\\n  - Simple syntax, easy to write and read.\\n  - Rich multilingual APIs.\\n  - Various path tools for data query, such as XPath, JsonPath, etc.\\n- Cons.\\n  - Too much redundant information: when the configuration scale is large, it is difficult to maintain the configuration, because important configuration information is hidden in a large number of irrelevant repetitive data details.\\n  - Lack of functionality: constraint, complex logic, test, debug, abstraction, etc.\\n  - [Kustomize](https://kustomize.io/)\'s patches are basically by fixing several patch merge strategies\\n\\nRepresentative technologies of structured KV include:\\n\\n- JSON/YAML: It is very convenient for reading and automation, and hasdifferent languages API support.\\n- [Kustomize](https://kustomize.io/): It provides a solution to customizethe Kubernetes resource base configuration and differential configurationwithout **template** and **DSL**. It does not solve the constraint problemitself, but needs to cooperate with a large number of additional tools tocheck constraints, such as [Kube-linter](https://github.com/stackroxkube-linter)\u3001[Checkov](https://github.com/bridgecrewio/checkov). Fig. 2shows the typical working mode of Kustomize.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/02-kustomize.png)\\n\\nFig. 2: Typical working mode of Kustomize.\\n\\n#### 1.2.3 Templated K-V\\n\\nThe Templated KV has the capability of static configuration data and dynamic parameters, and can output different static configuration data with one template+dynamic parameters. The advantages and disadvantages are as follows:\\n\\n- Pros.\\n  - Simple configuration logic and loop support.\\n  - External dynamic parameter support.\\n- Cons.\\n  - It is easy to fall into the trap that all configurations are template parameters.\\n  - When the configuration scale becomes larger, it is difficult for developers and tools to maintain and analyze them.\\n\\nRepresentative technologies of templated KV include:\\n\\n- [Helm](https://helm.sh/): The package management tool of Kubernetesresources, which manages the configuration of Kubernetes resources throughthe configuration template. Fig. 3 shows a Helm Jekins Package ConfigMapconfiguration template. It can be seen that these templates are very shortwith simple logic. A series of resource configurations suitable forKubernetes basic components are installed through package management andadditional configuration parameters. Compared with the simply templatedK-V, Helm provides template storage, reference and semantic versionmanagement capabilities. Compared with Kustomize, Helm is more suitablefor managing external Charts but is not good at multi-environment andmulti-tenant configuration management.\\n- Other configuration templates: Java Velocity, Go Template and other texttemplate engines are very suitable for HTML writing templates. However,when used in configuration scenarios, they are difficult for developersand tools to maintain and analyze.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/03-helm.png)\\n\\nFig. 3: Helm Jekins Package ConfigMap configuration template.\\n\\n#### 1.2.3 Programmable K-V\\n\\n`Configuration as Code (CaC)` uses code to generate configuration, just like engineers only need to write advanced GPL code, rather than manually writing error-prone and difficult-to-understand server binary code.\\n\\n- Configuration changes are treated as seriously as code changes, and unit tests and integration tests can also be executed.\\n- Code modularization is a key reason why maintaining configuration code is easier than manually editing configuration files such as JSON/YAML.\\n\\n- Capability\\n  - Necessary programming language abilities (variable definitions, logical judgments, loops, assertions, etc.).\\n  - Necessary template capability, which supports the definition of data templates and the use of templates to obtain new configuration data.\\n  - Code modularity: structure definition and package management.\\n  - Machine-readable and writable, human-readable and writable.\\n- Pros.\\n  - Necessary programming ability.\\n  - Code modularization and abstraction.\\n  - Configuration template and override ability.\\n- Cons.\\n  - Insufficient type check.\\n  - Insufficient constraint capacity.\\n  - Many runtime errors.\\n\\nRepresentative technologies of programmable KV include:\\n\\n- [GCL](https://github.com/rix0rrr/gcl): A declarative configurationprogramming language implemented in Python provides the necessary languagecapabilities to support template abstraction. However, the compiler itselfis written in Python, and the language itself is interpreted and executed.For large template instances (such as kubernetes model), the performanceis poor.\\n- [HCL](https://github.com/hashicorp/hcl): A Go implementation structuredconfiguration language. The native syntax of HCL is inspired by libucl andnginx configurations. It is used to create a structured configurationlanguage that is friendly to humans and machines, mainly for devops tools,server configurations, and resource configurations as a [Terraformlanguage](https://www.terraform.io/language).\\n- [Jsonnet](https://github.com/google/jsonnet): A data template languageimplemented in C++, suitable for application and tool developers, cangenerate configuration data and organize, simplify and manage largeconfigurations without side effects.\\n\\n#### 1.2.4 Typed K-V\\n\\n- Capability\\n  - Based on programmable K-V, typed K-V has more capabilities of type constraints.\\n- Pros.\\n  - The configuration merge is completely idempotent, which naturally prevents configuration conflicts.\\n  - Rich constraint syntax for writing configuration.\\n  - Abstract the type and value constraints into the same form, which is simple to write.\\n  - Configuration order independent.\\n- Cons.\\n  - The concepts of graph merging and idempotent merging are complex, and the understanding cost is high.\\n  - The mixed definition of type and value improves the degree of abstraction and the cost of understanding. All constraints are checked at runtime, and there is a performance bottleneck for the large-scale configuration code.\\n  - It is difficult to implement multi-tenant and multi-environment scenarios that want to configure coverage and modification.\\n  - For constrained scenarios with conditions, the user interface for writing hybrid definitions of definition and verification is unfriendly.\\n\\nRepresentative technologies of typed KV include:\\n\\n- [CUE](https://github.com/cue-lang/cue): The core problem CUE solves is\\"type checking\\", which is mainly used in configuration constraintverification scenarios and simple cloud native configuration scenarios.\\n\\n#### 1.2.5 Modeled K-V\\n\\n- Pros.\\n  - High-level language modeling capability as the core description\\n    - Modeling\\n    - Immutability\\n    - Constraints\\n  - High scalability through automatic merge mechanism of isolated config blocks.\\n  - Writing and testing methods like a high-level programming language.\\n  - Machine-readable and writable, human-readable and writable.\\n- Cons.\\n  - The expansion of new models and ecological construction requires certain R&D costs\\n\\nRepresentative technologies of modeled KV include:\\n\\n- [KCL](https://github.com/KusionStack/KCLVM): A declarative configurationand policy programming language implemented by Rust, which improves thewriting of a large number of complex configurations through matureprogramming language technology and practice, and is committed to buildingbetter modularity, scalability and stability around configuration, simplerlogic writing, fast automation and good ecological extensionally. Fig. 4shows a typical scenario of KCL writing application delivery configurationcode.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/04-kcl-app-code.png)\\n\\nFig. 4: A typical scenario of KCL writing application delivery configuration code.\\n\\n### 1.3 Guidelines and Best Practices for Different Declarative Configurations\\n\\n- Configuration scale: For small-scale configuration scenarios, we can use YAML/JSON and other configurations, such as the simple configuration of the application itself and CI/CD configuration. In addition, for the requirements of multi-environment and multi-tenant in small-scale configuration scenarios, Kustomize\'s overlay capability can be used to implement operations such as merging and covering simple configurations.\\n\\n- The necessity of model abstraction and constraint: For large-scale configuration scenarios, especially for those with urgent needs for configuration model and O&M feature R&D and precipitation of multi-tenant and multi-environment, the K-V method of coding, typing and modeling can be used.\\n\\nIn addition, consider the use scenarios of different declarative configurations:\\n\\n- YAML is recommended if you need to write structured static K-V or use Kubernetes\' native tools.\\n- HCL is recommended if you want to use programming language convenience to remove boilerplate with good human readability, or if you are already a Terraform user.\\n- CUE is recommended if you want to use a type system to improve stability and maintain scalable configurations.\\n- KCL is recommended if you want types and modelings like a modern language, scalable configurations, in-house pure functions and rules, and production-ready performance and automation.\\n\\nDifferent from other languages of the same type in the community, KCL is a static strongly typed compilation language for application developers and adopts modern language design and technology.\\n\\n> Note that this blog will not discuss the general language used for writing configuration. The general language is usually overkill, that is, it goes far beyond the problems that need to be solved. There are various security problems in the general language, such as the ability boundary problem (starting local threads, accessing IO, network, code infinitive looping and other security risks). For example, in the music field, there are special notes to express music, which is convenient for learning and communication, It can not be expressed clearly in general language.\\n>\\n> In addition, because of its various styles of the general language, which has the cost of unified maintenance, management and automation. The general language is usually used to write the client runtime, which is a continuation of the server runtime. It is not suitable for writing configurations that are independent of the runtime, and it is compiled into binary and started from the process finally. Besides, the stability and scalability are not easy to control. However, the configuration language often be used to write data, which is combined with simple logic, and it describes the expected final result, which is then consumed by the compiler or engine.\\n\\n## 2. KCL Core Features and Use Cases\\n\\nThe core features of KCL are its **modeling** and **constraint** capabilities, and the basic functions of KCL revolve around the two core features. In addition, KCL follows the user-centric configuration concept to design its basic functions, which can be understood from two aspects:\\n\\n- **Domain model-centric configuration view**: With the rich features of KCL language and [KCL OpenAPI](https://kcl-lang.io/docs/tools/cli/openapi/) tools, we can directly integrate a wide range of well-designed models in the community into KCL (such as the K8s resource model). We can also design and implement our own KCL models or libraries according to different scenarios, forming a complete set of domain models for other configuration end users to use.\\n- **End user-centric configuration view**: With KCL\'s code encapsulation, abstraction and reuse capabilities, the model architecture can be further abstracted and simplified (for example, the K8s resource model is abstracted into an application-centered server model) to **minimize the** end user configuration input**, simplify the user\'s configuration interface, and facilitate manual or automatic API modification.\\n\\nNo matter what configuration view is centered on, for configuration code, there are requirements for configuration data constraints, such as type constraints, required/optional constraints on configuration attributes, range constraints, and immutability constraints. This is also one of the core issues KCL is committed to solving. KCL mainly contains the core features shown in Fig. 5.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/05-kcl-core-feature.png)\\n\\nFig. 5: KCL core features.\\n\\n- **Easy-to-use**: Originated from high-level languages \u200b\u200bsuch as Python and Golang, incorporating functional language features with low side effects.\\n- **Well-designed**: Independent Spec-driven syntax, semantics, runtime and system modules design.\\n- **Quick modeling**: [Schema](https://kcl-lang.io/docs/reference/lang/tour#schema)-centric configuration types and modular abstraction.\\n- **Rich capabilities**: Configuration with type, logic and policy based on [Config](https://kcl-lang.io/docs/reference/lang/tour#config-operations), [Schema](https://kcl-lang.io/docs/reference/lang/tour#schema), [Lambda](https://kcl-lang.io/docs/reference/lang/tour#function), [Rule](https://kcl-lang.io/docs/reference/lang/tour#rule).\\n- **Stability**: Configuration stability built on [static type system](https://kcl-lang.io/docs/reference/lang/tour/#type-system), [constraints](https://kcl-lang.io/docs/reference/lang/tour/#validation), and [rules](https://kcl-lang.io/docs/reference/lang/tour#rule).\\n- **Scalability**: High scalability through [automatic merge mechanism](https://kcl-lang.io/docs/reference/lang/tour/#-operators-1) of isolated config blocks.\\n- **Fast automation**: Gradient automation scheme of [CRUD APIs](https://kcl-lang.io/docs/reference/lang/tour/#kcl-cli-variable-override), [multilingual SDKs](https://kcl-lang.io/docs/reference/xlang-api/overview), [language plugin](https://github.com/KusionStack/kcl-plugin)\\n- **High performance**: High compile time and runtime performance using Rust & C and [LLVM](https://llvm.org/), and support compilation to native code and [WASM](https://webassembly.org/).\\n- **API affinity**: Native support API ecological specifications such as [OpenAPI](https://github.com/KusionStack/kcl-openapi), Kubernetes CRD, Kubernetes YAML spec.\\n- **Development friendly**: Friendly development experiences with rich [language tools](https://kcl-lang.io/docs/tools/cli/kcl/) (Format, Lint, Test, Vet, Doc, etc.) and [IDE plugins](https://github.com/KusionStack/vscode-kcl).\\n- **Safety & maintainable**: Domain-oriented, no system-level functions such as native threads and IO, low noise and security risk, easy maintenance and governance.\\n- **Production-ready**: Widely used in production practice of platform engineering and automation at Ant Group.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/06-kcl-code-design.png)\\n\\nFig. 6: KCL core design.\\n\\nFor more language design and capabilities, see [KCL Documents](https://kcl-lang.io/docs/reference/lang/tour). Although KCL is not a general language, it has corresponding application scenarios. As shown in Fig. 6, developers can write **config**, **schema**, **function** and **rule** through KCL, where config is used to define data, schema is used to describe the model definition of data, rule is used to validate data, and schema and rule can also be combined to use models and constraints that fully describe data, In addition, we can also use the lambda pure function in KCL to organize data code, encapsulate common code, and call it directly when needed.\\n\\nFor use cases, KCL can perform structured K-V data validation complex configuration model definition and abstraction, strong constraint verification to avoid configuration errors, automation integration and engineering expansion. These features and use cases are described below.\\n\\n### 2.1 Validation of Structured Data\\n\\nAs shown in Fig 7, KCL supports format validation of JSON/YAML data. As a configuration language, KCL covers almost all features of OpenAPI in terms of validation. In KCL, the configuration data can be constrained by a structure definition. At the same time, it supports user-defined constraint rules through check blocks, and writing validation expressions in the schema to verify and constrain the attributes defined in the schema. The check expression can be used to clearly and simply verify whether the input JSON/YAML meets the corresponding schema structure definition and check constraints.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/07-kcl-validation.png)\\n\\nFig. 7: Validation of structured data in KCL.\\n\\nBased on this, KCL provides the corresponding [Validation Tool](https://kcl-lang.io/docs/tools/cli/kcl/vet) to validate JSON/YAML data directly.In addition, based on this capability, we can build a K-V validation visualization product as shown in Fig. 8.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/08-kcl-validation-ui.png)\\n\\nFig. 8: A K-V validation visualization product based on KCL.\\n\\n### 2.2 Definition and Abstraction of Complex Configuration Model\\n\\nAs shown in Fig 9, with the help of the [KCL OpenAPI](https://kcl-lang.io/docs/tools/cli/openapi/) tool, we can directly integrate a wide range of well-designed models.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/09-kcl-modeling.png)\\n\\nFig. 9: General way of KCL complex configuration modeling.\\n\\nAs shown in Figure 10, [Konfig](https://github.com/KusionStack/konfig) is used to manage all KCL configuration codes, the business configuration code and basic configuration code are stored in a mono repo, which facilitates the version dependency management between codes, and the automatic system processing is relatively simple. It is sufficient to locate the directory and files of the unique code base. The codes are interconnected, managed uniformly, and easy to find, modify, and maintain. Besieds, the unified CI/CD process can be used for configuration management.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/10-kcl-konfig.png)\\n\\nFig. 10: Using KCL\'s language capabilities to integrate domain models and user models.\\n\\n### 2.3 Strong Constraint to Avoid Errors\\n\\nAs shown in Fig. 11, configuration errors can be avoided through strong constraint checking methods in KCL.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/11-kcl-constraint.png)\\n\\nFig. 11: Strong constraint checking methods in KCL.\\n\\n- The KCL language\'s type system is designed to be static. Type and value definitions are separated. Type derivation and type checking at compile time are supported. Static types can not only analyze most type errors at compile time in advance, but also reduce the performance loss of dynamic type checking at runtime. In addition, the attributes of the KCL schema are forced to be not null, which can effectively avoid configuration omissions.\\n- When KCL configurations to be exported are declared, their types and values cannot change. This static feature ensures that the configuration will not be tampered with at will.\\n- KCL supports further ensuring stability through the built-in validation rules of the structure. For example, Fig. 12 shows that the KCL code defines the constraints for `containerPort`, `services`, and `volumes` in `App`.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/12-kcl-app-schema.png)\\n\\nFig. 12: KCL code validation with constraint rules.\\n\\n### 2.4 Isolated Configuration Block Merging\\n\\nKCL provides the ability to write isolated configuration blocks and automatically merge them, and supports idempotent merge, patch merge, and other strategies. Multiple configurations in idempotent merging need to meet the exchange law, and developers need to manually handle configuration conflicts between base and different environments. The patch merging includes overlay, deletion and addition. KCL simplifies the collaborative development on the user side and reduces the coupling between configurations through multiple merging strategies.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/13-kcl-isolated-config.png)\\n\\nFig. 13: Multi environment scenario configuration block writing.\\n\\n### 2.5 Automation\\n\\nKCL provides many automation related capabilities, mainly including tools and multilingual APIs. Via `package_identifier : key_identifier` mode, KCL supports the indexing of any configured key value, thus completing the addition, deletion, modification and query of any key value. For example, Fig 14. shows that we can directly execute the following command to modify the image. The code diff before and after modification is also shown in Fig. 14.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/14-kcl-image-update.png)\\n\\nFig. 14: Automatic modification of application configuration image via KCL CLI/API.\\n\\nIn addition, the automation capability of KCL can be realized as shown in Fig. 15 and integrated into CI/CD.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/15-kcl-automation.png)\\n\\nFig. 15: Typical KCL automation integration.\\n\\n## 3. Comparison between KCL and Other Declarative Configurations\\n\\n### 3.1 vs. JSON/YAML\\n\\nYAML/JSON configurations are suitable for small-scale configuration scenarios. For large-scale cloud native configuration scenarios that need frequent modifications, they are more suitable for KCL. The main difference involved is the difference between configuration data abstraction and deployment:\\n\\nThe advantages of using KCL for configuration are: for static data, the advantage of abstracting one layer means that the overall system has **deployment flexibility**. Different configuration environments, tenants, and runtime may have different requirements for static data, and even different organizations may have different specifications and product requirements. KCL can be used to expose the most needed and frequently modified configurations to users.\\n\\n### 3.2 vs. Kustomize\\n\\nThe core capability of Kustomize is its file level overlay capability. However, there is a problem of multiple overlay chains, because finding the statement of a specific attribute value does not guarantee that it is the final value, because another specific value that appears elsewhere can override it. For complex scenarios, retrieval of the inheritance chain of Kustomize files is often not as convenient as retrieval of the inheritance chain of KCL code, The specified configuration file overwrite order needs to be carefully considered. In addition, Kustomize cannot solve the problems of YAML configuration writing, constraint verification, model abstraction and development, and is more suitable for simple configuration scenarios.\\n\\nIn KCL, the configuration merge operation can be fine-grained to each configuration attribute in the code, and the merge strategy can be flexibly set, not limited to the overall resource, and the dependency between configurations can be statically analyzed through the import statement of KCL.\\n\\n### 3.3 vs. HCL\\n\\n#### 3.3.1 Features\\n\\n|  | HCL | KCL |\\n| --- | --- | --- |\\n| Modeling | The user interface is not directly perceived through the Terraform provider Schema definition. In addition, the user interface is cumbersome when writing complex object and required/optional field definitions. | Modeling through KCL schema, and achieve high model abstraction through language level engineering and some object-oriented features. |\\n| Constraint | The dynamic parameters are constrained by the condition field of the variable. The constraints of the resource itself need to be defined by provider schema or combined with Sentinel/Rego and other policy languages. The integrity of the language itself cannot be self closed, and its implementation methods are not unified | Define structures and constraints in a unified way. |\\n| Scalability | Terraform HCL overrides by file. The mode is fixed and the capability is limited. | KCL can customize the configuration block writing method and multiple strategies to meet the requirements of complex multi-tenant and multi-environment configuration scenarios. |\\n| Code writing | The user interface is complicated when writing complex object definitions and required/optional field definitions. | Complex structure definitions and constraint are easy to write without using other GPLs or tools. |\\n\\n#### 3.3.2 Examples\\n\\n**Terraform HCL variable vs. KCL schema**\\n\\n- HCL\\n\\n```python\\nvariable \\"subnet_delegations\\" {\\n  type = list(object({\\n    name               = string\\n    service_delegation = object({\\n      name    = string\\n      actions = list(string)\\n    })\\n  }))\\n  default     = null\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for d in var.subnet_delegations : (d != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for n in var.subnet_delegations.*.name : (n != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for d in var.subnet_delegations.*.service_delegation : (d != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for n in var.subnet_delegations.*.service_delegation.name : (n != null)])\\n  }\\n}\\n```\\n\\n- KCL\\n\\n```python\\nschema SubnetDelegation:\\n    name: str\\n    service_delegation: ServiceDelegation\\n\\nschema ServiceDelegation:\\n    name: str  # Required attributes\\n    actions?: [str]  # Optional attributes\\n\\nsubnet_delegations: [SubnetDelegation] = option(\\"subnet_delegations\\")\\n```\\n\\n**Terraform HCL Function vs. KCL Lambda**\\n\\n- As shown in [https://www.terraform.io/language/functions](https://www.terraform.io/language/functions) and [https://github.com/hashicorp/terraform/issues/27696](https://github.com/hashicorp/terraform/issues/27696)\uff0cTerraform HCL provides rich built-in functions, but it does not support users to define functions in Terraform (or need to write complex Go providers to simulate a local user-defined functions); KCL not only supports users to use the lambda keyword to directly define functions in KCL code, but also supports the use of Python, Go and other languages to write [plugins](https://kcl-lang.io/docs/reference/plugin/overview).\\n\\n- Defining functions and calling them in KCL\\n\\n```python\\nadd_func = lambda x: int, y: int -> int {\\n    x + y\\n}\\ntwo = add_func(1, 1)  # 2\\n```\\n\\n**Remove null values in HCL vs. Remove null values in KCL**\\n\\n- HCL\\n\\n```python\\nvariable \\"conf\\" {\\n  type = object({\\n    description = string\\n    name        = string\\n    namespace   = string\\n    params = list(object({\\n      default     = optional(string)\\n      description = string\\n      name        = string\\n      type        = string\\n    }))\\n    resources = optional(object({\\n      inputs = optional(list(object({\\n        name = string\\n        type = string\\n      })))\\n      outputs = optional(list(object({\\n        name = string\\n        type = string\\n      })))\\n    }))\\n    results = optional(list(object({\\n      name        = string\\n      description = string\\n    })))\\n    steps = list(object({\\n      args    = optional(list(string))\\n      command = optional(list(string))\\n      env = optional(list(object({\\n        name  = string\\n        value = string\\n      })))\\n      image = string\\n      name  = string\\n      resources = optional(object({\\n        limits = optional(object({\\n          cpu    = string\\n          memory = string\\n        }))\\n        requests = optional(object({\\n          cpu    = string\\n          memory = string\\n        }))\\n      }))\\n      script     = optional(string)\\n      workingDir = string\\n    }))\\n  })\\n}\\n\\nlocals {\\n  conf = merge(\\n    defaults(var.conf, {}),\\n    { for k, v in var.conf : k => v if v != null },\\n    { resources = { for k, v in var.conf.resources : k => v if v != null } },\\n    { steps = [for step in var.conf.steps : merge(\\n      { resources = {} },\\n      { for k, v in step : k => v if v != null },\\n    )] },\\n  )\\n}\\n```\\n\\n- KCL (using `-n` flag)\\n\\n```python\\nschema Param:\\n    default?: str\\n    name: str\\n\\nschema Resource:\\n    cpu: str\\n    memory: str\\n\\nschema Step:\\n    args?: [str]\\n    command?: [str]\\n    env?: {str:str}\\n    image: str\\n    name: str\\n    resources?: {\\"limits\\" | \\"requests\\": Resource}\\n    script?: str\\n    workingDir: str\\n\\nschema K8sManifest:\\n    name: str\\n    namespace: str\\n    params: [Param]\\n    results?: [str]\\n    steps: [Step]\\n\\nconf: K8sManifest = option(\\"conf\\")\\n```\\n\\nTo sum up, in KCL, its types and constraints are defined in a declarative way through schema. It can be seen that compared with Terraform HCL, KCL constraints can be written more simply when the same functions are implemented (validation and condition fields do not need to be written repeatedly like Terraform), In addition, it provides the ability to set fields as optional (unlike the Terraform configuration field, which can be null by default).\\n\\n### 3.4 vs. CUE\\n\\n#### 3.4.1 Features\\n\\n|  | CUE | KCL |\\n| --- | --- | --- |\\n| Modeling | Modeling through struct, no inheritance and other features, can achieve high abstraction when there is no conflict between model definitions. Because CUE performs all constraint checks at runtime, there may be performance bottlenecks in large-scale modeling scenarios. | Modeling is conducted through KCL schema, and high model abstraction can be achieved through language level engineering and some object-oriented features (such as single inheritance). KCL is a statically compiled language with low overhead for large-scale modeling scenarios. |\\n| Constraint | CUE combines types and values into one concept. It simplifies the writing of constraints through various syntax. For example, generic types and enumerations are not required. Summing types and null value merging are the same thing. | KCL provides a richer check declarative constraint syntax, which makes it easier to write. For some configuration field combination constraints, it is simpler to write (compared with CUE, KCL provides more if guard combination constraints, all/any/map/filter and other collection constraint writing methods, which makes it easier to write) |\\n| Scalability | CUE supports configuration merging but it is completely idempotent. It may not meet the requirements of complex multi-tenant and multi- environment configuration scenarios | KCL can customize the configuration block writing method and multiple strategies to meet the requirements of complex multi-tenant and multi-environment configuration scenarios. |\\n| Code writing | For complex loop and constraint scenarios, it is complex to write, and it is cumbersome to write scenarios that require accurate configuration modifications. | Complex structure definition, loop, and conditional constraint scenarios are easy to write. |\\n\\n#### 3.4.2 Examples\\n\\n**CUE constraint vs. KCL constraint**\\n\\nCUE (run `cue export base.cue prod.cue`)\\n\\n- base.cue\\n\\n```cue\\n// base.cue\\nimport \\"list\\"\\n\\n#App: {\\n    domainType: \\"Standard\\" | \\"Customized\\" | \\"Global\\",\\n    containerPort: >=1 & <=65535,\\n    volumes: [...#Volume],\\n    services: [...#Service],\\n}\\n\\n#Service: {\\n    clusterIP: string,\\n    type: string,\\n\\n    if type == \\"ClusterIP\\" {\\n        clusterIP: \\"None\\"\\n    }\\n}\\n\\n#Volume: {\\n    container: string | *\\"*\\"  // The default value of `container` is \\"*\\"\\n    mountPath: string,\\n    _check: false & list.Contains([\\"/\\", \\"/boot\\", \\"/home\\", \\"dev\\", \\"/etc\\", \\"/root\\"], mountPath),\\n}\\n\\napp: #App & {\\n    domainType: \\"Standard\\",\\n    containerPort: 80,\\n    volumes: [\\n        {\\n            mountPath: \\"/tmp\\"\\n        }\\n    ],\\n    services: [\\n        {\\n            clusterIP: \\"None\\",\\n            type: \\"ClusterIP\\"\\n        }\\n    ]\\n}\\n\\n```\\n\\n- prod.cue\\n\\n```python\\n// prod.cue\\napp: #App & {\\n    containerPort: 8080,  // error: app.containerPort: conflicting values 8080 and 80:\\n}\\n```\\n\\nKCL (run `kcl base.k prod.k`)\\n\\n- base.k\\n\\n```python\\n# base.k\\nschema App:\\n    domainType: \\"Standard\\" | \\"Customized\\" | \\"Global\\"\\n    containerPort: int\\n    volumes: [Volume]\\n    services: [Service]\\n\\n    check:\\n        1 <= containerPort <= 65535\\n\\nschema Service:\\n    clusterIP: str\\n    $type: str\\n\\n    check:\\n        clusterIP == \\"None\\" if $type == \\"ClusterIP\\"\\n\\nschema Volume:\\n    container: str = \\"*\\"  # The default value of `container` is \\"*\\"\\n    mountPath: str\\n\\n    check:\\n        mountPath not in [\\"/\\", \\"/boot\\", \\"/home\\", \\"dev\\", \\"/etc\\", \\"/root\\"]\\n\\napp: App {\\n    domainType = \\"Standard\\"\\n    containerPort = 80\\n    volumes = [\\n        {\\n            mountPath = \\"/tmp\\"\\n        }\\n    ]\\n    services = [\\n        {\\n            clusterIP = \\"None\\"\\n            $type = \\"ClusterIP\\"\\n        }\\n    ]\\n}\\n\\n```\\n\\n- prod.k\\n\\n```python\\n# prod.k\\napp: App {\\n    # Using `=` attribute operator to modify the `containerPort` of the base `app`.\\n    containerPort = 8080\\n    # Using `+=` attribute operator to add volumes of the base `app`.\\n    # Here, it means to add one volume in the prod environment.\\n    volumes += [\\n        {\\n            mountPath = \\"/tmp2\\"\\n        }\\n    ]\\n}\\n```\\n\\nIn addition, due to the idempotent merge feature of CUE, it is not easy to use an overlay configuration similar to Kustomize to override the addition capability in scenarios, such as the above CUE code will report an conflict error.\\n\\n### 3.5 Performance\\n\\nKCL performs better than CUE/Jsonnet/HCL and other languages in scenarios with large code size or high computation load (CUE and other languages are limited by the runtime constraint checking overhead, while KCL is a statically compiled language).\\n\\n- CUE (test.cue)\\n\\n```cue\\nimport \\"list\\"\\n\\ntemp: {\\n        for i, _ in list.Range(0, 10000, 1) {\\n                \\"a\\\\(i)\\": list.Max([1, 2])\\n        }\\n}\\n```\\n\\n- KCL (test.k)\\n\\n```python\\na = lambda x: int, y: int -> int {\\n    max([x, y])\\n}\\ntemp = {\\"a${i}\\": a(1, 2) for i in range(10000)}\\n```\\n\\n- Jsonnet (test.jsonnet)\\n\\n```jsonnet\\nlocal a(x, y) = std.max(x, y);\\n{\\n    temp: [a(1, 2) for i in std.range(0, 10000)],\\n}\\n```\\n\\n- Terraform HCL (test.tf. Since the terraform `range` function only supports up to 1024 iterators, the `range(10000)` is divided into 10 sub ranges)\\n\\n```python\\noutput \\"r1\\" {\\n  value = {for s in range(0, 1000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r2\\" {\\n  value = {for s in range(1000, 2000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r3\\" {\\n  value = {for s in range(1000, 2000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r4\\" {\\n  value = {for s in range(2000, 3000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r5\\" {\\n  value = {for s in range(3000, 4000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r6\\" {\\n  value = {for s in range(5000, 6000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r7\\" {\\n  value = {for s in range(6000, 7000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r8\\" {\\n  value = {for s in range(7000, 8000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r9\\" {\\n  value = {for s in range(8000, 9000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r10\\" {\\n  value = {for s in range(9000, 10000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\n```\\n\\n- Running time (considering the actual resource cost of the production environment, this test is subject to the single core).\\n\\n| Environment | KCL v0.4.3 Running time (including compilation+runtime) | CUE v0.4.3 Running time (including compilation+runtime) | Jsonnet v0.18.0 Running time (including compilation+runtime)  | HCL in Terraform v1.3.0 Running time (including compilation+runtime) |\\n| --- | --- | --- | --- | --- |\\n| OS: macOS 10.15.7; CPU: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz; Memory: 32 GB 2400 MHz DDR4; no NUMA | 440 ms (kclvm_cli run test.k) | 6290 ms (cue export test.cue) | 1890 ms (jsonnet test.jsonnet) | 1774 ms (terraform plan -parallelism=1) |\\n\\n#### Another Complex Case\\n\\nUsing KCL and CUE to write Kubernetes configuration.\\n\\n- CUE (test.cue)\\n\\n```cue\\npackage templates\\n\\nimport (\\n apps \\"k8s.io/api/apps/v1\\"\\n)\\n\\ndeployment: apps.#Deployment\\n\\ndeployment: {\\n apiVersion: \\"apps/v1\\"\\n kind:       \\"Deployment\\"\\n metadata: {\\n  name:   \\"me\\"\\n  labels: me: \\"me\\"\\n }\\n}\\n```\\n\\n- KCL (test.k)\\n\\n```python\\nimport kubernetes.api.apps.v1\\n\\ndeployment = v1.Deployment {\\n    metadata.name = \\"me\\"\\n    metadata.labels.name = \\"me\\"\\n}\\n```\\n\\n| Environment | KCL v0.4.3 Running time (including compilation+runtime) | CUE v0.4.3 Running time (including compilation+runtime) |\\n| --- | --- | --- |\\n| OS: macOS 10.15.7; CPU: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz; Memory: 32 GB 2400 MHz DDR4; no NUMA | 140 ms (kclvm_cli run test.k) | 350 ms (cue export test.cue) |\\n\\n## 4. Summary\\n\\nThe blog gives the landscape overview of declarative configuration technology, focusing on the KCL concept, core features, usage cases and comparison with other configuration languages, hoping to help you understand declarative configuration technology and KCL language. For more information about the concept, background and design of KCL, please visit the [KCL website](https://kcl-lang.io/)\\n\\n## 5. Reference\\n\\n- KusionStack Cloud Native Configuration Practice Blog: [https://kusionstack.io/blog/2021-kusion-intro](https://kusionstack.io/blog/2021-kusion-intro)\\n- Terraform Language: [https://www.terraform.io/language](https://www.terraform.io/language)\\n- Terraform Provider Kubernetes: [https://github.com/hashicorp/terraform-provider-kubernetes](https://github.com/hashicorp/terraform-provider-kubernetes)\\n- Terraform Provider AWS: [https://github.com/hashicorp/terraform-provider-aws](https://github.com/hashicorp/terraform-provider-aws)\\n- Pulumi: [https://www.pulumi.com/docs/](https://www.pulumi.com/docs/)\\n- Pulumi vs. Terraform: [https://www.pulumi.com/docs/intro/vs/terraform/](https://www.pulumi.com/docs/intro/vs/terraform/)\\n- Google SRE Work Book Configuration Design: [https://sre.google/workbook/configuration-design/](https://sre.google/workbook/configuration-design/)\\n- Google Borg Paper: [https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf)\\n- Holistic Configuration Management at Facebook: [https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf](https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf)\\n- JSON Spec: [https://www.json.org/json-en.html](https://www.json.org/json-en.html)\\n- YAML Spec: [https://yaml.org/spec/](https://yaml.org/spec/)\\n- GCL: [https://github.com/rix0rrr/gcl](https://github.com/rix0rrr/gcl)\\n- HCL: [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)\\n- CUE: [https://github.com/cue-lang/cue](https://github.com/cue-lang/cue)\\n- Jsonnet: [https://github.com/google/jsonnet](https://github.com/google/jsonnet)\\n- Dhall: [https://github.com/dhall-lang/dhall-lang](https://github.com/dhall-lang/dhall-lang)\\n- Thrift: [https://github.com/Thriftpy/thriftpy2](https://github.com/Thriftpy/thriftpy2)\\n- Kustomize: [https://kustomize.io/](https://kustomize.io/)\\n- Kube-linter: [https://github.com/stackrox/kube-linter](https://github.com/stackrox/kube-linter)\\n- Checkov: [https://github.com/bridgecrewio/checkov](https://github.com/bridgecrewio/checkov)\\n- KCL Documents: [https://kcl-lang.io/docs/reference/lang/tour](https://kcl-lang.io/docs/reference/lang/tour)\\n- How Terraform Works: A Visual Intro: [https://betterprogramming.pub/how-terraform-works-a-visual-intro-6328cddbe067](https://betterprogramming.pub/how-terraform-works-a-visual-intro-6328cddbe067) \\n- How Terraform Works: Modules Illustrated: [https://awstip.com/terraform-modules-illustrate-26cbc48be83a](https://awstip.com/terraform-modules-illustrate-26cbc48be83a)\\n- Helm: [https://helm.sh/](https://helm.sh/)\\n- Helm vs. Kustomize: [https://harness.io/blog/helm-vs-kustomize](https://harness.io/blog/helm-vs-kustomize)\\n- KubeVela: [https://kubevela.io/docs/](https://kubevela.io/docs/)"},{"id":"2021-kcl-intro","metadata":{"permalink":"/blog/2021-kcl-intro","editUrl":"https://github.com/KusionStack/kcl-lang.io/blob/main/blog/2021-08-03-kcl-intro/index.md","source":"@site/blog/2021-08-03-kcl-intro/index.md","title":"KCL - Cloud Native Configuration and Policy Language","description":"This blog introduces the birth background, language characteristics, practical exploration and future development of KCL.","date":"2021-08-03T00:00:00.000Z","formattedDate":"August 3, 2021","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":0.125,"truncated":false,"authors":[{"name":"Shushan, Chai","title":"KCL Team Member"}],"frontMatter":{"slug":"2021-kcl-intro","title":"KCL - Cloud Native Configuration and Policy Language","authors":{"name":"Shushan, Chai","title":"KCL Team Member"},"tags":["KCL"]},"prevItem":{"title":"The Landscape of Declarative Configuration","permalink":"/blog/2022-declarative-config-overview"}},"content":"This blog introduces the birth background, language characteristics, practical exploration and future development of KCL.\\n\\n- Introduction\uff1ahttps://giac.msup.com.cn/course?id=15307\\n- Content\uff1ahttps://segmentfault.com/a/1190000040455559\\n- [PDF (Chinese)](https://gw.alipayobjects.com/os/bmw-prod/2cb0c283-5f24-485e-b635-b6efac887eba.pdf)\\n\\n[![KCL Talk Cover](/img/blog/2021-08-03-kcl-intro/talk-cover.png)](https://gw.alipayobjects.com/os/bmw-prod/2cb0c283-5f24-485e-b635-b6efac887eba.pdf)"}]}')}}]);